var documenterSearchIndex = {"docs":
[{"location":"environment/","page":"Environment","title":"Environment","text":"CurrentModule = Kokkos","category":"page"},{"location":"environment/#Environment","page":"Environment","title":"Environment","text":"","category":"section"},{"location":"environment/#Initialization","page":"Environment","title":"Initialization","text":"","category":"section"},{"location":"environment/","page":"Environment","title":"Environment","text":"initialize\nis_initialized\nfinalize\nis_finalized\nload_wrapper_lib\nis_kokkos_wrapper_loaded","category":"page"},{"location":"environment/#Kokkos.initialize","page":"Environment","title":"Kokkos.initialize","text":"initialize(;\n    num_threads=nothing,\n    device_id=nothing, map_device_id_by=nothing,\n    disable_warnings=nothing, print_configuration=nothing,\n    tune_internals=nothing,\n    tools_libs=nothing, tools_args=nothing\n)\n\nInitializes Kokkos by calling Kokkos::initialize().\n\nThe keyword arguments build are passed to the InitializationSettings constructor which is then passed to Kokkos::initialize(). A value of nothing keeps the default behaviour of Kokkos.\n\nThe Kokkos wrapper library is loaded (and recompiled if needed) if it is not already the case. This locks the current Configuration Options until the end of the current Julia session.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.is_initialized","page":"Environment","title":"Kokkos.is_initialized","text":"is_initialized()\n\nReturn Kokkos::is_initialized().\n\nCan be called before the wrapper library is loaded.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.finalize","page":"Environment","title":"Kokkos.finalize","text":"finalize()\n\nCalls Kokkos::finalize().\n\ninfo: Info\nIf Kokkos isn't already finalized, finalize will be called automatically at process exit through Base.atexit.\n\nwarning: Warning\nKokkos requires that all view destructors should be called before calling finalize. This is done automatically for all views allocated through Kokkos.jl upon calling finalize, and therefore they will all become invalid.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.is_finalized","page":"Environment","title":"Kokkos.is_finalized","text":"is_finalized()\n\nReturn Kokkos::is_finalized().\n\nCan be called before the wrapper library is loaded.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.Wrapper.load_wrapper_lib","page":"Environment","title":"Kokkos.Wrapper.load_wrapper_lib","text":"load_wrapper_lib(; no_compilation=false, no_git=false, loading_bar=true)\n\nConfigures, compiles then loads the wrapper library using the current Configuration Options.\n\nAfter calling this method, all configuration options become locked.\n\nIf no_compilation is true, then the CMake project of the wrapper library will not be configured or compiled.\n\nIf no_git is true, then if we need to use the Kokkos installation of the package, no Git operations (clone + checkout) will be done.\n\nBoth no_compilation=true and no_git=true are needed when initializing Kokkos.jl in non-root MPI processes.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.is_kokkos_wrapper_loaded","page":"Environment","title":"Kokkos.is_kokkos_wrapper_loaded","text":"is_kokkos_wrapper_loaded()\n\nReturn true if load_wrapper_lib has been called.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Configuration","page":"Environment","title":"Configuration","text":"","category":"section"},{"location":"environment/","page":"Environment","title":"Environment","text":"build_in_scratch\nbuild_in_tmp\nbuild_in_project\nconfiginfo\nversioninfo\nprint_configuration\nset_omp_vars","category":"page"},{"location":"environment/#Kokkos.build_in_scratch","page":"Environment","title":"Kokkos.build_in_scratch","text":"build_in_scratch()\n\nSets the build_dir configuration option to a scratch directory (the default).\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.build_in_tmp","page":"Environment","title":"Kokkos.build_in_tmp","text":"build_in_tmp()\n\nSets the build_dir configuration option to a temporary directory, cleaned at the end of the Julia session.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.build_in_project","page":"Environment","title":"Kokkos.build_in_project","text":"build_in_project(name = \".kokkos-build\")\n\nSets the build_dir configuration option to the directory name in the active project directory.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.configinfo","page":"Environment","title":"Kokkos.configinfo","text":"configinfo(io::IO = stdout)\n\nPrint information about all configuration options.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.versioninfo","page":"Environment","title":"Kokkos.versioninfo","text":"versioninfo(io::IO = stdout; internal=true, verbose=false)\n\nPrint the version and various information about the underlying Kokkos library.\n\nIf internal is true, Kokkos::print_configuration() is called. verbose is passed to that call.\n\nThis function does not require for Kokkos to be initialized, however if internal=true then the output will be incomplete.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.print_configuration","page":"Environment","title":"Kokkos.print_configuration","text":"print_configuration(io::IO, verbose::Bool)\n\nPrints the internal Kokkos configuration to io.\n\nEquivalent to Kokkos::print_configuration(out, verbose).\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.set_omp_vars","page":"Environment","title":"Kokkos.set_omp_vars","text":"set_omp_vars(;\n    places = \"cores\",\n    bind = \"close\",\n    num_threads = Threads.nthreads()\n)\n\nHelper function to set the main OpenMP environment variables used by Kokkos. It must be called before calling initialize.\n\nplaces sets OMP_PLACES. bind sets OMP_PROC_BIND. num_threads sets OMP_NUM_THREADS.\n\nNote that since Julia threads and OpenMP threads are decoupled, there is no constraint imposed by Julia on OpenMP threads: there can be as many threads as needed.\n\nwarning: Warning\nPinning the Julia threads with ThreadPinning.jl or with the JULIA_EXCLUSIVE environment variable can have an impact on OpenMP thread affinities, making the OpenMP variables useless.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Synchronization","page":"Environment","title":"Synchronization","text":"","category":"section"},{"location":"environment/","page":"Environment","title":"Environment","text":"fence","category":"page"},{"location":"environment/#Kokkos.fence","page":"Environment","title":"Kokkos.fence","text":"fence()\nfence(label::String)\n\nWait for all asynchronous Kokkos operations to complete.\n\nEquivalent to Kokkos::fence().\n\n\n\n\n\n","category":"function"},{"location":"environment/#Constants","page":"Environment","title":"Constants","text":"","category":"section"},{"location":"environment/","page":"Environment","title":"Environment","text":"KOKKOS_VERSION","category":"page"},{"location":"environment/#Kokkos.KOKKOS_VERSION","page":"Environment","title":"Kokkos.KOKKOS_VERSION","text":"KOKKOS_VERSION::VersionNumber\n\nThe Kokkos version currently loaded.\n\nnothing if Kokkos is not yet loaded. See kokkos_version for the version of the packaged installation of Kokkos, which is defined before loading Kokkos.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"CurrentModule = Kokkos","category":"page"},{"location":"spaces/#Execution-and-Memory-Spaces","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"Space\nExecutionSpace\nMemorySpace\naccessible(::Serial, ::HostSpace)\narray_layout(::Space)\nenabled\nexecution_space\nmemory_space(::Space)\nmain_space_type\nimpl_space_type\nkokkos_name\nfence(::ExecutionSpace)\nconcurrency\nallocate\ndeallocate","category":"page"},{"location":"spaces/#Kokkos.Space","page":"Execution & Memory Spaces","title":"Kokkos.Space","text":"Space\n\nAbstract super type of all execution and memory spaces.\n\nMain subtypes:\n\nExecutionSpaces: super type of all execution spaces\nMemorySpaces: super type of all memory spaces\n\nAll Kokkos spaces have a main abstract type (Serial, Cuda, HostSpace, HIPSpace...) which are defined even if it has not been compiled on the C++ side. Those main abstract types should be the ones used when specifying a space. This allows methods like enabled to work independently from the wrapper library.\n\nWhen a space is enabled, a sub-type of its main type is defined by CxxWrap, leading to the following type structure: SerialImplAllocated <: SerialImpl <: Serial <: ExecutionSpace <: Space. Below the main space type (here, Serial), the sub-types are only defined if they are enabled, and therefore they should not be relied upon.\n\nNavigating the type tree can be made easier through main_space_type.\n\n\n\n\n\n","category":"type"},{"location":"spaces/#Kokkos.ExecutionSpace","page":"Execution & Memory Spaces","title":"Kokkos.ExecutionSpace","text":"ExecutionSpace <: Space\n\nAbstract super-type of all execution spaces.\n\nSub-types:\n\nSerial\nOpenMP\nOpenACC\nOpenMPTarget\nThreads\nCuda\nHIP\nHPX\nSYCL\n\nAll sub-types are always defined, but only some of them are enabled. To enable an execution space, you must enable its related Kokkos backend, e.g. \"-DKokkos_ENABLE_SERIAL=ON\" for the Serial execution space.\n\nTo do this you can set the backends option with Kokkos.set_backends, or specify the option directly through kokkos_options.\n\n\n\n\n\n","category":"type"},{"location":"spaces/#Kokkos.MemorySpace","page":"Execution & Memory Spaces","title":"Kokkos.MemorySpace","text":"MemorySpace <: Space\n\nAbstract super-type of all memory spaces.\n\nSub-types:\n\nHostSpace\nCudaSpace\nCudaHostPinnedSpace\nCudaUVMSpace\nHIPSpace\nHIPHostPinnedSpace\nHIPManagedSpace\n\nSub-types work the same as for ExecutionSpace. They can be enabled by enabling their respective backend.\n\n\n\n\n\n","category":"type"},{"location":"spaces/#Kokkos.accessible-Tuple{Kokkos.Serial, Kokkos.HostSpace}","page":"Execution & Memory Spaces","title":"Kokkos.accessible","text":"accessible([S1::Union{<:Space, Type{<:Space}},] S2::Union{<:MemorySpace, Type{<:MemorySpace}})\n\nReturn true if the memory space S2 is accessible from S1 (a memory or execution space).\n\nIf only S2 is specified, S1 defaults to DEFAULT_HOST_SPACE.\n\nEquivalent to Kokkos::SpaceAccessibility<S1, S2>::accessible\n\n\n\n\n\n","category":"method"},{"location":"spaces/#Kokkos.array_layout-Tuple{Kokkos.Space}","page":"Execution & Memory Spaces","title":"Kokkos.array_layout","text":"array_layout(exec_space::Union{<:ExecutionSpace, Type{<:ExecutionSpace}})\n\nReturn the default array layout type of the given execution space.\n\n\n\n\n\n","category":"method"},{"location":"spaces/#Kokkos.enabled","page":"Execution & Memory Spaces","title":"Kokkos.enabled","text":"enabled(space::Union{Space, Type{<:Space}})\n\nReturn true if the given execution or memory space is enabled.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.execution_space","page":"Execution & Memory Spaces","title":"Kokkos.execution_space","text":"execution_space(space::Union{<:MemorySpace, Type{<:MemorySpace}})\n\nReturn the execution space associated by default to the given memory space.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.memory_space-Tuple{Kokkos.Space}","page":"Execution & Memory Spaces","title":"Kokkos.memory_space","text":"memory_space(space::Union{<:ExecutionSpace, Type{<:ExecutionSpace}})\n\nReturn the memory space associated by default to the given execution space.\n\n\n\n\n\n","category":"method"},{"location":"spaces/#Kokkos.main_space_type","page":"Execution & Memory Spaces","title":"Kokkos.main_space_type","text":"main_space_type(space::Union{<:Space, Type{<:Space}})\n\nReturn the main space type of space, e.g. for Serial, SerialImpl or SerialImplAllocated we get Serial.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.impl_space_type","page":"Execution & Memory Spaces","title":"Kokkos.impl_space_type","text":"impl_space_type(::Type{<:Space})\n\nOpposite of main_space_type: from the main space type (Serial, OpenMP, HostSpace...) return the implementation type (SerialImpl, OpenMPImpl, HostSpaceImpl...). The given space must be enabled.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.kokkos_name","page":"Execution & Memory Spaces","title":"Kokkos.kokkos_name","text":"kokkos_name(space::Union{Space, Type{<:Space}})\n\nReturn the name of the execution or memory space as defined by Kokkos.\n\nEquivalent to Kokkos::space::name()\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.fence-Tuple{Kokkos.ExecutionSpace}","page":"Execution & Memory Spaces","title":"Kokkos.fence","text":"fence(exec_space::ExecutionSpace)\n\nWait for all asynchronous tasks operating on this execution space instance to complete.\n\nEquivalent to exec_space.fence().\n\n\n\n\n\n","category":"method"},{"location":"spaces/#Kokkos.concurrency","page":"Execution & Memory Spaces","title":"Kokkos.concurrency","text":"concurrency(exec_space::ExecutionSpace)\n\nThe maximum number of threads utilized by the execution space instance.\n\nEquivalent to exec_space.concurrency().\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.allocate","page":"Execution & Memory Spaces","title":"Kokkos.allocate","text":"allocate(mem_space::MemorySpace, bytes)\n\nAllocate bytes on the memory space instance. Returns a pointer to the allocated memory.\n\nEquivalent to mem_space.allocate(bytes)\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.deallocate","page":"Execution & Memory Spaces","title":"Kokkos.deallocate","text":"deallocate(mem_space::MemorySpace, ptr)\n\nFrees ptr, previously allocated with allocate.\n\nEquivalent to mem_space.deallocate(ptr, bytes)\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Constants","page":"Execution & Memory Spaces","title":"Constants","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"ENABLED_EXEC_SPACES\nENABLED_MEM_SPACES","category":"page"},{"location":"spaces/#Kokkos.ENABLED_EXEC_SPACES","page":"Execution & Memory Spaces","title":"Kokkos.ENABLED_EXEC_SPACES","text":"ENABLED_EXEC_SPACES::Tuple{Vararg{Type{<:ExecutionSpace}}}\n\nList of all enabled Kokkos execution spaces.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.ENABLED_MEM_SPACES","page":"Execution & Memory Spaces","title":"Kokkos.ENABLED_MEM_SPACES","text":"ENABLED_MEM_SPACES::Tuple{Vararg{Type{<:MemorySpace}}}\n\nList of all enabled Kokkos memory spaces.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Default-spaces","page":"Execution & Memory Spaces","title":"Default spaces","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"DEFAULT_DEVICE_SPACE\nDEFAULT_DEVICE_MEM_SPACE\nDEFAULT_HOST_SPACE\nDEFAULT_HOST_MEM_SPACE\nSHARED_MEMORY_SPACE\nSHARED_HOST_PINNED_MEMORY_SPACE","category":"page"},{"location":"spaces/#Kokkos.DEFAULT_DEVICE_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.DEFAULT_DEVICE_SPACE","text":"DEFAULT_DEVICE_SPACE::Type{<:ExecutionSpace}\n\nThe default execution space where kernels are applied on the device.\n\nEquivalent to Kokkos::DefaultExecutionSpace.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.DEFAULT_DEVICE_MEM_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.DEFAULT_DEVICE_MEM_SPACE","text":"DEFAULT_DEVICE_MEM_SPACE::Type{<:MemorySpace}\n\nThe default memory space where views are stored on the device.\n\nEquivalent to Kokkos::DefaultExecutionSpace::memory_space.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.DEFAULT_HOST_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.DEFAULT_HOST_SPACE","text":"DEFAULT_HOST_SPACE::Type{<:ExecutionSpace}\n\nThe default execution space where kernels are applied on the host.\n\nEquivalent to Kokkos::DefaultHostExecutionSpace.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.DEFAULT_HOST_MEM_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.DEFAULT_HOST_MEM_SPACE","text":"DEFAULT_HOST_MEM_SPACE::Type{<:MemorySpace}\n\nThe default memory space where views are stored on the host.\n\nEquivalent to Kokkos::DefaultHostExecutionSpace::memory_space.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.SHARED_MEMORY_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.SHARED_MEMORY_SPACE","text":"SHARED_MEMORY_SPACE::Union{Nothing, Type{<:MemorySpace}}\n\nThe shared memory space between the host and device, or nothing if there is none.\n\nEquivalent to Kokkos::SharedSpace if Kokkos::has_shared_space is true.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.SHARED_HOST_PINNED_MEMORY_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.SHARED_HOST_PINNED_MEMORY_SPACE","text":"SHARED_HOST_PINNED_MEMORY_SPACE::Union{Nothing, Type{<:MemorySpace}}\n\nThe shared pinned memory space between the host and device, or nothing if there is none.\n\nEquivalent to Kokkos::SharedHostPinnedSpace if Kokkos::has_shared_host_pinned_space is true.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Backend-specific-methods","page":"Execution & Memory Spaces","title":"Backend-specific methods","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"Those unexported methods are defined in the Kokkos.BackendFunctions module. They have methods only if their respective backend is enabled and Kokkos is initialized.","category":"page"},{"location":"spaces/#OpenMP","page":"Execution & Memory Spaces","title":"OpenMP","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"Some functions of the OpenMP runtime are made available through Kokkos.jl, mostly for debugging purposes and tracking thread affinity.","category":"page"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"BackendFunctions.omp_set_num_threads\nBackendFunctions.omp_get_max_threads\nBackendFunctions.omp_get_proc_bind\nBackendFunctions.omp_get_num_places\nBackendFunctions.omp_get_place_num_procs\nBackendFunctions.omp_get_place_proc_ids\nBackendFunctions.omp_capture_affinity","category":"page"},{"location":"spaces/#Kokkos.BackendFunctions.omp_set_num_threads","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.omp_set_num_threads","text":"omp_set_num_threads(threads::Cint)::Cvoid\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.omp_get_max_threads","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.omp_get_max_threads","text":"omp_get_max_threads()::Cint\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.omp_get_proc_bind","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.omp_get_proc_bind","text":"omp_get_proc_bind()::Cint\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.omp_get_num_places","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.omp_get_num_places","text":"omp_get_num_places()::Cint\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.omp_get_place_num_procs","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.omp_get_place_num_procs","text":"omp_get_place_num_procs(place::Cint)::Cint\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.omp_get_place_proc_ids","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.omp_get_place_proc_ids","text":"omp_get_place_proc_ids(place::Cint)::Vector{Cint}\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.omp_capture_affinity","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.omp_capture_affinity","text":"omp_capture_affinity([format::String])::String\n\nMore or less equivalent to  omp_display_affinity(char*), but applies the given format (or OpenMP's default one) to each OpenMP thread using  omp_capture_affinity, and returns the result.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Cuda-/-HIP","page":"Execution & Memory Spaces","title":"Cuda / HIP","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"BackendFunctions.device_id\nBackendFunctions.wrap_stream\nBackendFunctions.stream_ptr\nBackendFunctions.memory_info","category":"page"},{"location":"spaces/#Kokkos.device_id","page":"Execution & Memory Spaces","title":"Kokkos.device_id","text":"device_id([space::Kokkos.Cuda])\ndevice_id([space::Kokkos.HIP])\n\nReturn the ID of the device associated with the given space. If space is not given, the ID of the default device used by Kokkos is returned.\n\nThe ID is a 0-index in the list of available devices (as used by cudaGetDeviceProperties or hipGetDeviceProperties for example).\n\nEquivalent to Kokkos::Cuda().cuda_device() or Kokkos::HIP().hip_device().\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.wrap_stream","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.wrap_stream","text":"wrap_stream(cuda_stream::Ptr{Cvoid})::Kokkos.Cuda\nwrap_stream(hip_stream::Ptr{Cvoid})::Kokkos.HIP\n\nReturn a Kokkos.Cuda or Kokkos.HIP execution space operating on the given stream (a pointer to a cudaStream_t or hipStream_t respectively). Kokkos does not take ownership of the stream.\n\nEquivalent to Kokkos::Cuda(cuda_stream) or Kokkos::HIP(hip_stream).\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.stream_ptr","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.stream_ptr","text":"stream_ptr(space::Kokkos.Cuda)\nstream_ptr(space::Kokkos.HIP)\n\nReturn the cudaStream_t or hipStream_t of the space as a Ptr{Cvoid}.\n\nEquivalent to Kokkos::Cuda().cuda_stream() or Kokkos::HIP().hip_stream().\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.BackendFunctions.memory_info","page":"Execution & Memory Spaces","title":"Kokkos.BackendFunctions.memory_info","text":"memory_info()\n\nReturn (free_memory, total_memory), in bytes, for the current active device.\n\nEquivalent to cuMemGetInfo_v2 or hipMemGetInfo.\n\n\n\n\n\n","category":"function"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"CurrentModule = Kokkos","category":"page"},{"location":"config_options/#Configuration-Options","page":"Configuration options","title":"Configuration Options","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Configuration options are set using Preferences.jl. Your LocalPreferences.jl file will store the options needed by your current project in a [Kokkos] section.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"danger: Important\nUnlike some packages using Preferences.jl, it is possible to change all options during the same Julia session, using their setters. However, if you need to dynamically configure Kokkos.jl, it must be done before loading the wrapper library. After calling load_wrapper_lib (or initialize), all options will be locked, and any changes made afterward will not affect the current Julia session.","category":"page"},{"location":"config_options/#kokkos_version","page":"Configuration options","title":"kokkos_version","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The version of Kokkos to use. Must be a valid version tag in the official Kokkos repository (e.g. \"4.0.00\").","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Only used when kokkos_path is not set, and defaults to the one of the packaged sources of kokkos.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Each version is stored in the package's scratch space, which is checked-out upon loading the Kokkos wrapper.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Special versions like latest or 3.7-latest are supported:","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"latest: use the latest release\n3-latest: use the latest release of major version 3\n4.1-latest: use the latest release of major and minor versions 4 and 1","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_kokkos_version(). The value for the current Julia session is stored in Kokkos.LOCAL_KOKKOS_VERSION_STR.","category":"page"},{"location":"config_options/#kokkos_path","page":"Configuration options","title":"kokkos_path","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The path to the Kokkos sources (not an installation!) to use. If not set, it defaults to the Kokkos version packaged with Kokkos.jl.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_kokkos_path(). The value for the current Julia session is stored in Kokkos.KOKKOS_PATH.","category":"page"},{"location":"config_options/#cmake_options","page":"Configuration options","title":"cmake_options","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The list of CMake options to pass to all CMakeKokkosProjects.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_cmake_options(). The value for the current Julia session is stored in Kokkos.KOKKOS_CMAKE_OPTIONS.","category":"page"},{"location":"config_options/#kokkos_options","page":"Configuration options","title":"kokkos_options","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The list of Kokkos options to pass to all KokkosProjects.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"It can be passed as a list of \"Kokkos_<option_name>=<value>\", or as a Dict{String, Any} (Bool values will be converted to \"ON\" and \"OFF\", others to strings).","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_kokkos_options(). The value for the current Julia session is stored in Kokkos.KOKKOS_LIB_OPTIONS.","category":"page"},{"location":"config_options/#backends","page":"Configuration options","title":"backends","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The list of Kokkos backends to compile for. When in uppercase and prefixed by Kokkos_ENABLE_ the names should correspond to one of the valid device backends options. Defaults to Serial and OpenMP.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_backends(), using a vector of String or ExecutionSpace subtypes.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The value for the current Julia session is stored in Kokkos.KOKKOS_BACKENDS.","category":"page"},{"location":"config_options/#build_type","page":"Configuration options","title":"build_type","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"CMake build type.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_build_type(). The value for the current Julia session is stored in Kokkos.KOKKOS_BUILD_TYPE.","category":"page"},{"location":"config_options/#build_dir","page":"Configuration options","title":"build_dir","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Main building directory for the current session. The wrapping library is built in $(build_dir)/wrapper-build-$(build_type)/.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_build_dir(), Kokkos.build_in_scratch, Kokkos.build_in_tmp or Kokkos.build_in_project. The value for the current Julia session is stored in Kokkos.KOKKOS_BUILD_DIR.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"note: Note\nKokkos.set_build_dir() accepts a kwarg local_only (default: false) which allows to set the build directory without writing to LocalPreferences.toml.This is only useful in MPI applications, where only one process should modify the confiuration options and compile code. Calling Kokkos.set_build_dir(build_dir; local_only=true) on non-root processes will allow them to find the libraries compiled by the root process.","category":"page"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"CurrentModule = Kokkos","category":"page"},{"location":"compilation/#Compilation","page":"Compilation","title":"Compilation","text":"","category":"section"},{"location":"compilation/#Kokkos-Projects","page":"Compilation","title":"Kokkos Projects","text":"","category":"section"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"KokkosProject\nCMakeKokkosProject\nbuild_dir\nsource_dir\nlib_path\noptions\noption!\nconfiguration_changed\nconfiguration_changed!\nconfigure\ncompile\nclean","category":"page"},{"location":"compilation/#Kokkos.KokkosProject","page":"Compilation","title":"Kokkos.KokkosProject","text":"KokkosProject\n\nAbstract type representing a C++ project using Kokkos, where it is located and how to compile it using which options.\n\n\n\n\n\n","category":"type"},{"location":"compilation/#Kokkos.CMakeKokkosProject","page":"Compilation","title":"Kokkos.CMakeKokkosProject","text":"CMakeKokkosProject(source_dir, target_lib_path;\n    target = \"all\",\n    build_type = \"Release\",\n    build_dir = joinpath(source_dir, \"cmake-build-$(lowercase(build_type))\"),\n    cmake_options = [],\n    kokkos_path = nothing,\n    kokkos_options = nothing,\n    inherit_options = true\n)\n\nConstruct a new Kokkos project in source_dir built to build_dir using CMake. After compilation, the target library should be found at joinpath(build_dir, target_lib_path).\n\nThe shared library extension of target_lib_path can be omitted, as it is added if needed by Libdl.dlopen.\n\ntarget is the CMake target needed to build the library.\n\nbuild_type controls the CMAKE_BUILD_TYPE variable, and cmake_options contains all other options passed to each CMake command.\n\nkokkos_path sets the Kokkos_ROOT CMake variable, to be used by find_package.\n\nkokkos_path should be left to nothing in most cases, as it will be replaced by the installation directory of Kokkos correctly configured with the current options (see get_kokkos_install_dir).\n\nwarning: Warning\nThe Kokkos version of the project must match the version used by the internal wrapper library. If this is not the case, the program may silently fail. Use the kokkos_path configuration variable to change the Kokkos version throughout Kokkos.jl.\n\nkokkos_options is a Dict of Kokkos variables needed to configure the project (see the docs). Values of type Bool are converted to \"ON\" and \"OFF\", all other types directly are converted to strings. Each variable is then passed to CMake as \"-D$(name)=$(value)\".\n\nIf inherit_options is true, the cmake_options of the Kokkos wrapper project will be appended at the front of the new project's cmake_options. kokkos_options are not inherited here since Kokkos's CMake mechanisms do this automatically.\n\nAll commands are invoked from the current working directory.\n\n\n\n\n\nCMakeKokkosProject(project::CMakeKokkosProject, target, target_lib_path)\n\nConstruct a project from another, for a different target.\n\nThe source and build directories will stay the same, and options will be copied.\n\n\n\n\n\n","category":"type"},{"location":"compilation/#Kokkos.build_dir","page":"Compilation","title":"Kokkos.build_dir","text":"build_dir(project::KokkosProject)\n\nReturn the build directory of project.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.source_dir","page":"Compilation","title":"Kokkos.source_dir","text":"source_dir(project::KokkosProject)\n\nReturn the source directory of project.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.lib_path","page":"Compilation","title":"Kokkos.lib_path","text":"lib_path(project::KokkosProject)\n\nReturn the path to the target library for project.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.options","page":"Compilation","title":"Kokkos.options","text":"options(project::KokkosProject)\n\nReturn the set of options to the target library for project.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.option!","page":"Compilation","title":"Kokkos.option!","text":"option!(project::KokkosProject, name::String, val; prefix=\"Kokkos_\")\n\nSets the given Kokkos option for the project to val. This will result in the following compilation option: \"-D$(prefix)$(name)=$(val)\".\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.configuration_changed","page":"Compilation","title":"Kokkos.configuration_changed","text":"configuration_changed(project::KokkosProject)\n\nReturn true if the configuration of project changed, and needs to be recompiled.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.configuration_changed!","page":"Compilation","title":"Kokkos.configuration_changed!","text":"configuration_changed!(project::KokkosProject, val::Bool = true)\n\nSets the configuration state of project to val.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.configure","page":"Compilation","title":"Kokkos.configure","text":"configure(project::KokkosProject)\n\nConfigure the project with its current options.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.compile","page":"Compilation","title":"Kokkos.compile","text":"compile(project::KokkosProject)\n\nBuilds all source files of the project.\n\nIf the project's configuration changed, it is reconfigured first.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.clean","page":"Compilation","title":"Kokkos.clean","text":"clean(project::KokkosProject; reset=false)\n\nClean the project, forcing a recompilation of all source files.\n\nIf reset == true, the entire build_dir is removed, therefore ensuring that no cached CMake variable can interfere with the build.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Utilities","page":"Compilation","title":"Utilities","text":"","category":"section"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"get_jlcxx_root\nget_kokkos_build_dir\nget_kokkos_dir\nget_kokkos_install_dir\nWrapper.clean_cmake_files","category":"page"},{"location":"compilation/#Kokkos.Wrapper.get_jlcxx_root","page":"Compilation","title":"Kokkos.Wrapper.get_jlcxx_root","text":"get_jlcxx_root()\n\nReturn the directory where the file \"JlCxxConfig.cmake\" is located for the currently loaded CxxWrap package.\n\nSetting the CMake variable JlCxx_ROOT to this path allows the CMake function find_package to load JlCxx. \n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.Wrapper.get_kokkos_build_dir","page":"Compilation","title":"Kokkos.Wrapper.get_kokkos_build_dir","text":"get_kokkos_build_dir()\n\nThe directory where Kokkos is compiled.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.Wrapper.get_kokkos_dir","page":"Compilation","title":"Kokkos.Wrapper.get_kokkos_dir","text":"get_kokkos_dir()\n\nThe directory where the sources of Kokkos are located.\n\nIf KOKKOS_PATH is not set, it defaults to the sources of Kokkos packaged with Kokkos.jl.\n\nThis directory is meant to be passed to the CMake function add_subdirectory in order to load Kokkos as an in-tree build.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.Wrapper.get_kokkos_install_dir","page":"Compilation","title":"Kokkos.Wrapper.get_kokkos_install_dir","text":"get_kokkos_install_dir()\n\nThe directory where Kokkos is installed.\n\nThis directory can be passed to the CMake function find_package through the Kokkos_ROOT variable in order to load Kokkos with the same options and backends as the ones used by Kokkos.jl.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.Wrapper.clean_cmake_files","page":"Compilation","title":"Kokkos.Wrapper.clean_cmake_files","text":"clean_cmake_files()\n\nClears the CMake cache of the wrapper library, and removes all build files, as well as compiled function libraries.\n\n\n\n\n\n","category":"function"},{"location":"MPI/","page":"MPI","title":"MPI","text":"CurrentModule = Kokkos","category":"page"},{"location":"MPI/#Using-Kokkos.jl-with-MPI.jl","page":"MPI","title":"Using Kokkos.jl with MPI.jl","text":"","category":"section"},{"location":"MPI/#Loading-and-compilation","page":"MPI","title":"Loading and compilation","text":"","category":"section"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Since calling Kokkos.initialize may trigger the compilation of the internal wrapper library, some care is needed to make sure only a single process is compiling.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"A basic initialization workflow with MPI may look like this:","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"using MPI\nusing Kokkos\n\nMPI.Init()\n\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nif rank == 0\n    Kokkos.load_wrapper_lib()  # All compilation (if any) of the C++ wrapper happens here\nend\n\nMPI.Barrier(MPI.COMM_WORLD)\n\nrank != 0 && Kokkos.load_wrapper_lib(; no_compilation=true, no_git=true)\nKokkos.initialize()","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Note that passing no_compilation=true and no_git=true to load_wrapper_lib on the non-root processes is required.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"The same workflow can be used to compile your library on the root process:","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"my_project = CMakeKokkosProject(project_src, \"libproj\")\nrank == 0 && compile(my_project)\nMPI.Barrier(MPI.COMM_WORLD)\nlib = load_lib(my_project)","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"If configuration options need to be changed before initializing Kokkos, then they must be changed by the root process, since changing options will modify the LocalPreferrences.toml file. Configuration options only affect how the wrapper library is compiled, therefore there is no need to synchronize them on all processes, apart from one: build_dir, which MUST be the same on all processes. Passing local_only=true to Kokkos.set_build_dir for non-root processes will not affect the LocalPreferrences.toml file. The new workflow then looks like this:","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"rank = MPI.Comm_rank(MPI.COMM_WORLD)\nif rank == 0\n    Kokkos.set_view_types(my_view_types)\n    # set other config options...\n    Kokkos.set_build_dir(my_build_dir)\n    Kokkos.load_wrapper_lib()\nelse\n    Kokkos.set_build_dir(my_build_dir; local_only=true)\nend\n\nMPI.Barrier(MPI.COMM_WORLD)\n\nrank != 0 && Kokkos.load_wrapper_lib(; no_compilation=true, no_git=true)","category":"page"},{"location":"MPI/#Dynamic-Compilation-and-MPI","page":"MPI","title":"Dynamic Compilation and MPI","text":"","category":"section"},{"location":"MPI/","page":"MPI","title":"MPI","text":"See DynamicCompilation.compilation_lock","category":"page"},{"location":"MPI/#Passing-views-to-MPI","page":"MPI","title":"Passing views to MPI","text":"","category":"section"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Passing a Kokkos.View to a MPI directive is possible:","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"v = View{Float64}(n)\nv .= MPI.Comm_rank(MPI.COMM_WORLD)\n\nr = View{Float64}(n)\n\nMPI.Sendrecv!(v, next_rank, 0, r, prev_rank, 0, MPI.COMM_WORLD)\n\n@assert all(r .== prev_rank)","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Internally, the pointer to the data of the view is passed to MPI, there is no copy of the data, regardless of the memory space where the view is stored in.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"If Kokkos.span_is_contiguous(view) == true, then the whole memory span of the view is passed to MPI as a single block of data.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"For non-contiguous views (such as LayoutStride), a custom MPI.Datatype is built to exactly represent the view.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Support for GPU-awareness should be seamless, as long as your MPI implementation supports the GPU.","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"CurrentModule = Kokkos","category":"page"},{"location":"inaccessible_views/#Using-views-in-an-inaccessible-memory-space","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"","category":"section"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"By Kokkos semantics, it is not possible to read or write views which are stored in an inaccessible memory space (accessible(view) == false). Therefore views on a GPU device (stored in a CudaSpace, HIPSpace, etc...) cannot be displayed:","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"julia> v = Kokkos.View{Float64}(10; mem_space=Kokkos.CudaSpace)\n10-element Kokkos.Views.View{Float64, 1, Kokkos.LayoutLeft, Kokkos.CudaSpace}: <inaccessible view>","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"This can be viewed as a stricter version of allowscalar(false) in CUDA.jl or AMDGPU.jl.","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"The correct approch is the same as in C++: creating a host copy of the view.","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"julia> host_v = Kokkos.create_mirror_view(v; mem_space=Kokkos.HostSpace());\n\njulia> copyto!(host_v, v)  # Calls `Kokkos.deep_copy`\n\njulia> host_v\n10-element Kokkos.Views.View{Float64, 1, Kokkos.LayoutLeft, Kokkos.HostSpace}:\n 0.0\n 0.0\n 0.0\n...\n\njulia> host_v[1] = 1\n1\n\njulia> copyto!(v, host_v)\n","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"The strength of this approach is the fact that it will be efficient whatever the device backend is. create_mirror_view will simply return the view passed to it if the memory space is the same, making it effectively a no-op. Same for deep_copy, which is a no-op if both arguments are the same.","category":"page"},{"location":"library_management/","page":"Library Management","title":"Library Management","text":"CurrentModule = Kokkos","category":"page"},{"location":"library_management/#Library-Management","page":"Library Management","title":"Library Management","text":"","category":"section"},{"location":"library_management/","page":"Library Management","title":"Library Management","text":"CLibrary\nhandle\nget_symbol\nload_lib\nunload_lib\nis_lib_loaded","category":"page"},{"location":"library_management/#Kokkos.CLibrary","page":"Library Management","title":"Kokkos.CLibrary","text":"CLibrary\n\nA wrapper around a shared library, loaded with Libdl.dlopen.\n\n\n\n\n\n","category":"type"},{"location":"library_management/#Kokkos.handle","page":"Library Management","title":"Kokkos.handle","text":"handle(lib::CLibrary)\n\nReturn the handle (a Ptr{Nothing}) of lib, for use with Libdl.dlsym for example.\n\nIf lib is invalid (not loaded), returns C_NULL.\n\n\n\n\n\n","category":"function"},{"location":"library_management/#Kokkos.get_symbol","page":"Library Management","title":"Kokkos.get_symbol","text":"get_symbol(lib::CLibrary, symbol::Symbol)\n\nLoad the pointer to the given symbol. Symbol pointers are cached: Libdl.dlsym is called only if the symbol is not already in the cache.\n\n\n\n\n\n","category":"function"},{"location":"library_management/#Kokkos.load_lib","page":"Library Management","title":"Kokkos.load_lib","text":"load_lib(lib::Union{String, KokkosProject, CLibrary};\n         flags=Libdl.RTLD_LAZY | Libdl.RTLD_LOCAL)\n\nOpen a shared library.\n\nlib can be the path to the shared library, an existing CLibrary or a KokkosProject. If lib is a project, its target is supposed to be compiled and up-to-date.\n\nIf the library is already loaded, it is not opened another time: this guarantees that calling Libdl.dlclose once will unload the library from memory, if the library wasn't opened from elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"library_management/#Kokkos.unload_lib","page":"Library Management","title":"Kokkos.unload_lib","text":"unload_lib(lib::Union{KokkosProject, CLibrary})\n\nUnload a library. Return true if the library has a valid handle and Libdl.dlclose was called.\n\nBecause of the mechanism behind shared library loading, it is not guaranteed that the library is unloaded from memory after this call. is_lib_loaded is more reliable than the return value of this function.\n\nThe symbol cache of the library is cleared by this function.\n\n\n\n\n\n","category":"function"},{"location":"library_management/#Kokkos.is_lib_loaded","page":"Library Management","title":"Kokkos.is_lib_loaded","text":"is_lib_loaded(lib::Union{KokkosProject, CLibrary})\n\nReturn true if the library was previously loaded by load_lib and is still present in memory.\n\nIf the full path to lib is still present in Libdl.dllist(), the library is considered to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"interop/#Interoperability","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability","text":"","category":"section"},{"location":"interop/#CUDA.jl","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"CUDA.jl","text":"","category":"section"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"Views can be converted into CuArrays using Base.unsafe_wrap:","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"Base.unsafe_wrap(::Type{CUDA.CuArray}, ::Kokkos.View)","category":"page"},{"location":"interop/#Base.unsafe_wrap-Tuple{Type{CuArray}, Kokkos.Views.View}","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Base.unsafe_wrap","text":"unsafe_wrap(CuArray, v::Kokkos.View)\n\nWrap a Kokkos.View into a CuArray. The view must be stored in one of the CUDA device memory spaces.\n\nViews with row-major layout (LayoutRight) will be transposed with Base.adjoint.\n\nNon-contiguous views (Kokkos.span_is_contiguous(v) == false) cannot be represented as CuArrays.\n\nwarning: Warning\nThe returned CuArray does not own the data of the view, which then must stay rooted for the entire lifetime of the CuArray.\n\n\n\n\n\n","category":"method"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"And CuArrays can be converted into views with Kokkos.view_wrap:","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"julia> A = CuArray{Int64}(undef, 4, 4);\n\njulia> CUDA.@allowscalar for i in eachindex(A)\n           A[i] = i\n       end\n\njulia> A\n44 CuArray{Int64, 2, CUDA.Mem.DeviceBuffer}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> A_v = Kokkos.view_wrap(A)\n44 Kokkos.Views.View{Int64, 2, Kokkos.LayoutLeft, Kokkos.CudaSpace}: <inaccessible view>","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"SubArrays of CuArrays (or, more precisely, any CUDA.StridedSubCuArray), can also be converted into views with a LayoutStride:","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"julia> sub_A = @view A[2:3, 2:3];\n\njulia> sub_A isa CUDA.StridedSubCuArray\ntrue\n\njulia> size(sub_A), strides(sub_A)\n((2, 2), (1, 4))\n\njulia> sub_A_v = Kokkos.view_wrap(sub_A)\n22 Kokkos.Views.View{Int64, 2, Kokkos.LayoutStride, Kokkos.CudaSpace}: <inaccessible view>\n\njulia> size(sub_A_v), strides(sub_A_v)\n((2, 2), (1, 4))","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"Unlike Kokkos.View, it is possible to perform arithmetic operations on a CuArray from the host, as well as indexing device memory (if permitted by CUDA.allowscalar(true) or CUDA.@allowscalar).","category":"page"},{"location":"interop/#AMDGPU.jl","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"AMDGPU.jl","text":"","category":"section"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"Views can be converted into ROCArrays using Base.unsafe_wrap:","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"Base.unsafe_wrap(::Type{AMDGPU.ROCArray}, ::Kokkos.View)","category":"page"},{"location":"interop/#Base.unsafe_wrap-Tuple{Type{ROCArray}, Kokkos.Views.View}","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Base.unsafe_wrap","text":"unsafe_wrap(ROCArray, v::Kokkos.View)\n\nWrap a Kokkos.View into a ROCArray. The view must be stored in one of the HIP device memory spaces.\n\nViews with row-major layout (LayoutRight) will be transposed with Base.adjoint.\n\nNon-contiguous views (Kokkos.span_is_contiguous(v) == false) cannot be represented as ROCArrays.\n\nwarning: Warning\nThe returned ROCArray does not own the data of the view, which then must stay rooted for the entire lifetime of the ROCArray.\n\n\n\n\n\n","category":"method"},{"location":"interop/","page":"Interoperability with CUDA.jl and AMDGPU.jl","title":"Interoperability with CUDA.jl and AMDGPU.jl","text":"And ROCArrays can be converted into views with Kokkos.view_wrap, in the same manner as for CuArrays.","category":"page"},{"location":"dynamic_compilation/","page":"Dynamic Compilation","title":"Dynamic Compilation","text":"CurrentModule = Kokkos.DynamicCompilation","category":"page"},{"location":"dynamic_compilation/#Dynamic-Compilation","page":"Dynamic Compilation","title":"Dynamic Compilation","text":"","category":"section"},{"location":"dynamic_compilation/","page":"Dynamic Compilation","title":"Dynamic Compilation","text":"Functions used to compile on demand the Kokkos functions needed.","category":"page"},{"location":"dynamic_compilation/","page":"Dynamic Compilation","title":"Dynamic Compilation","text":"This mechanism allows to create new methods without degrading performance (after method  invalidation).","category":"page"},{"location":"dynamic_compilation/","page":"Dynamic Compilation","title":"Dynamic Compilation","text":"Only functions operating on views are dynamically compiled, the rest are compiled with the wrapper library.","category":"page"},{"location":"dynamic_compilation/","page":"Dynamic Compilation","title":"Dynamic Compilation","text":"Compilation is not thread-safe and must be done by a single process (and single thread) at once. This is ensured by compilation_lock.","category":"page"},{"location":"dynamic_compilation/","page":"Dynamic Compilation","title":"Dynamic Compilation","text":"@compile_and_call\ncompile_and_load\nhas_specialization\ncall_more_specific\nclean_libs\ncompilation_lock","category":"page"},{"location":"dynamic_compilation/#Kokkos.DynamicCompilation.@compile_and_call","page":"Dynamic Compilation","title":"Kokkos.DynamicCompilation.@compile_and_call","text":"@compile_and_call(method, args, compile)\n\nIf has_specialization(method, args) then invoke method, otherwise compile is executed. In both cases, method is invoked through Base.invokelatest.\n\nThis handles the following case:\n\nfunction my_method(@nospecialize(x))\n    return @compile_and_call(my_method, x, begin #= ... =# end)\nend\n\nfunction my_program(x)\n    my_method(x)  # Will compile\n    my_method(x)\nend\n\nHere the second invocation of my_method is still done in the same world in which my_program was invoked, even though the first invocation increased the global world counter. Therefore, we need to ensure method has not been specialized in the latest world before trying to compile.\n\n\n\n\n\n","category":"macro"},{"location":"dynamic_compilation/#Kokkos.DynamicCompilation.compile_and_load","page":"Dynamic Compilation","title":"Kokkos.DynamicCompilation.compile_and_load","text":"compile_and_load(current_module, cmake_target; kwargs...)\n\nCheck if the library of cmake_target compiled with kwargs exists, if not compile it, then load it.\n\nThe library is a CxxWrap module, which is then loaded into current_module in the sub-module Impl<number> with '<number>' the total count of calls to compile_and_load in this Julia session.\n\n\n\n\n\n","category":"function"},{"location":"dynamic_compilation/#Kokkos.DynamicCompilation.has_specialization","page":"Dynamic Compilation","title":"Kokkos.DynamicCompilation.has_specialization","text":"has_specialization(func, args_t::Tuple{Vararg{Type}})\n\nTrue if the most specific method of func applicable to args_t has no @nospecialize annotation on any argument.\n\n\n\n\n\n","category":"function"},{"location":"dynamic_compilation/#Kokkos.DynamicCompilation.call_more_specific","page":"Dynamic Compilation","title":"Kokkos.DynamicCompilation.call_more_specific","text":"call_more_specific(func, args)\n\nCall func with args with Base.invokelatest(func, args...), but only if there is a specialized method for the arguments (an error is raised otherwise).\n\nAfter calling compile_and_load from a @nospecialize method meant to define a new method specialized for args, this function will prevent infinite recursion if the new method is not applicable to args.\n\n\n\n\n\n","category":"function"},{"location":"dynamic_compilation/#Kokkos.DynamicCompilation.clean_libs","page":"Dynamic Compilation","title":"Kokkos.DynamicCompilation.clean_libs","text":"clean_libs()\n\nRemove all shared libraries generated for compilation on demand of some methods or types.\n\nLibraries are not unloaded, therefore subsequent calls to compile_and_load might not trigger recompilation.\n\n\n\n\n\n","category":"function"},{"location":"dynamic_compilation/#Kokkos.DynamicCompilation.compilation_lock","page":"Dynamic Compilation","title":"Kokkos.DynamicCompilation.compilation_lock","text":"compilation_lock(func)\n\nAsserts that only a single process (and single thread) is compiling at once.\n\nBy default, there is only a lock on tasks of the current process.\n\nIf MPI.jl is loaded, a PID lock file is also used (see FileWatching.Pidfile, or Pidfile.jl before 1.9). Lock files have the advantage that no collective MPI operations are needed, however they only work if all MPI ranks share the same filesystem, and if this is not the case then there is no need for lock files. This can be overloaded with the JULIA_KOKKOS_USE_COMPILATION_LOCK_FILE environment variable.\n\nNote that it is not the current process' ID that is used in the PID lock file, since PID are not guaranteed to be unique in a MPI application. Instead a random 32-bit number is used, constant for this process.\n\n\n\n\n\n","category":"function"},{"location":"views/","page":"Views","title":"Views","text":"CurrentModule = Kokkos.Views","category":"page"},{"location":"views/#Views","page":"Views","title":"Views","text":"","category":"section"},{"location":"views/#View","page":"Views","title":"View","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"View\naccessible(::View)\nmemory_space(::View)\narray_layout(::View)\nlabel\nview_data\nmemory_span\nspan_is_contiguous\nsubview\nview_wrap\ndeep_copy\nhost_mirror\nhost_mirror_space\ncreate_mirror\ncreate_mirror_view\nimpl_view_type\nmain_view_type\ncxx_type_name","category":"page"},{"location":"views/#Kokkos.Views.View","page":"Views","title":"Kokkos.Views.View","text":"View{T, D, Layout, MemSpace} <: AbstractArray{T, D}\n\nWrapper around a Kokkos::View of D dimensions of type T, stored in MemSpace using the Layout.\n\nBehaves like a normal Array. Indexing is done by calling the Kokkos::View::operator() function of the view, and is therefore not highly performant. The best performance with Kokkos views is achieved by calling Kokkos kernels compiled from C++.\n\nIt is supposed that all view accesses are done from the default host execution space. Since the view may be stored in a memory space different from the host, it may be invalid to access its elements: if accessible(MemSpace) is false, then all view accesses will throw an error.\n\nViews are created through CxxWrap.jl, which adds automatically a finalizer to all objects which calls the view's destructor when the Julia object is deleted by the garbage collector.\n\nIt is important to understand that for a view to be properly disposed of, there is two requirements:\n\nthe library containing its destructor is still loaded. Views created by the Kokkos.jl library will always meet this requirement.\nfinalize wasn't called.\n\n\n\n\n\n","category":"type"},{"location":"views/#Kokkos.accessible-Tuple{Kokkos.Views.View}","page":"Views","title":"Kokkos.accessible","text":"accessible(::View)\naccessible(::Type{<:View})\n\nReturn true if the view is accessible from the default host execution space.\n\n\n\n\n\n","category":"method"},{"location":"views/#Kokkos.memory_space-Tuple{Kokkos.Views.View}","page":"Views","title":"Kokkos.memory_space","text":"memory_space(::View)\nmemory_space(::Type{<:View})\n\nThe memory space type in which the view data is stored.\n\njulia> my_cuda_space = Kokkos.CudaSpace()\n ...\n\njulia> v = View{Float64}(undef, 10; mem_space=my_cuda_space)\n ...\n\njulia> memory_space(v)\nKokkos.CudaSpace\n\n\n\n\n\n","category":"method"},{"location":"views/#Kokkos.array_layout-Tuple{Kokkos.Views.View}","page":"Views","title":"Kokkos.array_layout","text":"array_layout(::View)\narray_layout(::Type{<:View})\n\nReturn the Layout type of the view.\n\n\n\n\n\n","category":"method"},{"location":"views/#Kokkos.Views.label","page":"Views","title":"Kokkos.Views.label","text":"label(::View)\n\nReturn the label of the View.\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.view_data","page":"Views","title":"Kokkos.Views.view_data","text":"view_data(::View)\n\nThe pointer to the data of the View. Using Base.pointer(view) is preferred over this method.\n\nEquivalent to view.data().\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.memory_span","page":"Views","title":"Kokkos.Views.memory_span","text":"memory_span(::View)\n\nTotal size of the view data in memory, in bytes.\n\nEquivalent to view.impl_map().memory_span().\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.span_is_contiguous","page":"Views","title":"Kokkos.Views.span_is_contiguous","text":"span_is_contiguous(::View)\n\ntrue if the view stores all its elements contiguously in memory.\n\nEquivalent to view.span_is_contiguous().\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.subview","page":"Views","title":"Kokkos.Views.subview","text":"subview(v::View, indexes...)\nsubview(v::View, indexes::Tuple{Vararg{Union{Int, Colon, AbstractUnitRange}}})\n\nReturn a new Kokkos.view which will be a subview into the region specified by indexes of v, with the same memory space (but maybe not the same layout).\n\nUnspecified dimensions are completed by :, e.g. if v is a 3D view (1,) and (1, :, :) will return the same subview.\n\nIf v is tracked to be automatically finalized, then the subview will be as well.\n\nEquivalent to Kokkos::subview.\n\nKokkos::ALL is equivalent to :.\n\nExample\n\njulia> v = Kokkos.View{Float64}(undef, 4, 4);\n\njulia> v[:] .= collect(1:length(v));\n\njulia> v\n44 Kokkos.Views.View{Float64, 2, Kokkos.LayoutRight, Kokkos.HostSpace}:\n 1.0  5.0   9.0  13.0\n 2.0  6.0  10.0  14.0\n 3.0  7.0  11.0  15.0\n 4.0  8.0  12.0  16.0\n\njulia> Kokkos.subview(v, (2:3, 2:3))\n22 Kokkos.Views.View{Float64, 2, Kokkos.LayoutRight, Kokkos.HostSpace}:\n 6.0  10.0\n 7.0  11.0\n\njulia> Kokkos.subview(v, (:, 1))  # The subview may change its layout to `LayoutStride` \n4-element Kokkos.Views.View{Float64, 1, Kokkos.LayoutStride, Kokkos.HostSpace}:\n 1.0\n 2.0\n 3.0\n 4.0\n\njulia> Kokkos.subview(v, (1,))  # Equivalent to `(1, :)`\n4-element Kokkos.Views.View{Float64, 1, Kokkos.LayoutRight, Kokkos.HostSpace}:\n  1.0\n  5.0\n  9.0\n 13.0\n\nwarning: Warning\nKokkos.subview is not equivalent to Base.view, as it returns a new Kokkos.View object, while Base.view returns a SubArray, which cannot be passed to a ccall.\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.view_wrap","page":"Views","title":"Kokkos.Views.view_wrap","text":"view_wrap(array::AbstractArray{T, D})\nview_wrap(array::DenseArray{T, D})\nview_wrap(array::SubArray{T, D})\nview_wrap(::Type{View{T, D, L, S}}, d::NTuple{D, Int}, p::Ptr{T}; layout = nothing)\n\nConstruct a new View from the data of a Julia-allocated array (or from any valid array or pointer). The returned view does not own the data: no copy is made.\n\nThe memory space S is HostSpace when array is a DenseArray or AbstractArray, and the layout L is LayoutLeft for DenseArray and LayoutStride for AbstractArray.\n\nIf L is LayoutStride, then the kwarg layout should be an instance of a LayoutStride which specifies the stride of each dimension.\n\nwarning: Warning\nJulia arrays have a column-major layout by default. This correspond to a LayoutLeft, while Kokkos prefers LayoutRight for CPU allocated arrays. If strides(array)  strides(view_wrap(array)) then it might lead to segfaults. This only concerns 2D arrays and above.\n\nwarning: Warning\nThe returned view does not hold a reference to the original array. It is the responsibility of the user to make sure the original array is kept alive as long as the view should be accessed.\n\nnote: Note\nOverloads for CuArrays of CUDA.jl as well as for CUDA.StridedSubCuArray (using a LayoutStride), and ROCArrays of AMDGPU.jl are also available.\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.deep_copy","page":"Views","title":"Kokkos.Views.deep_copy","text":"deep_copy(dest::View, src::View)\ndeep_copy(space::ExecutionSpace, dest::View, src::View)\n\nPerforms a copy of all data from src to dest.\n\nIn order for the copy to be possible, both views must have the same dimension, and either have the same layout or are both accessible from space.\n\nIf a space is given, the copy may be asynchronous. If not the copy will be synchronous.\n\nEquivalent to Kokkos::deep_copy(dest, src) or Kokkos::deep_copy(space, dest, src). See the Kokkos docs about Kokkos::deep_copy\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.host_mirror","page":"Views","title":"Kokkos.Views.host_mirror","text":"host_mirror(view_t::Type{<:View})\nhost_mirror(view::View)\n\nThe view type which mirrors the given view on host space.\n\nNot rigorously equivalent to Kokkos::View<...>::HostMirror, since view hooks are not supported, but apart from this, it should be exactly equivalent.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.host_mirror_space","page":"Views","title":"Kokkos.Views.host_mirror_space","text":"host_mirror_space(view_t::Type{<:View})\nhost_mirror_space(view::View)\n\nThe type of the host execution space which mirrors this view's space.\n\nEquivalent to Kokkos::View<...>::traits::host_mirror_space.\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.create_mirror","page":"Views","title":"Kokkos.Views.create_mirror","text":"create_mirror(src::View; mem_space = nothing, zero_fill = false, track = true)\n\nCreate a new View in the same way as similar(src), with the same layout and padding as src.\n\nIf mem_space is nothing the new view will be in a memory space accessible by the host, otherwise it must be a memory space instance where the new view will be allocated.\n\nIf zero_fill is true, the new view will have all of its elements set to their default value.\n\nSee the Kokkos docs about Kokkos::create_mirror\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.create_mirror_view","page":"Views","title":"Kokkos.Views.create_mirror_view","text":"create_mirror_view(src::View; mem_space = nothing, zero_fill = false, track = true)\n\nEquivalent to create_mirror, but if src is already accessible by the host, src is returned and no view is created.\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.impl_view_type","page":"Views","title":"Kokkos.Views.impl_view_type","text":"impl_view_type(::Type{View{T, D, L, S}})\n\nReturns the internal View type for the given complete View type.\n\nThe opposite of main_view_type.\n\njulia> view_t = Kokkos.View{Float64, 2, Kokkos.LayoutRight, Kokkos.HostSpace}\nKokkos.Views.View{Float64, 2, Kokkos.Views.LayoutRight, Kokkos.HostSpace}\n\njulia> view_impl_t = Kokkos.impl_view_type(view_t)\nKokkos.Wrapper.Impl.View2D_R_HostAllocated{Float64}\n\njulia> supertype(supertype(view_impl_t))\nKokkos.Views.View{Float64, 2, Kokkos.Views.LayoutRight, Kokkos.Wrapper.Impl.HostSpaceImplAllocated}\n\njulia> view_impl_t <: view_t  # Julia types are contra-variant\nfalse\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.main_view_type","page":"Views","title":"Kokkos.Views.main_view_type","text":"main_view_type(::View)\nmain_view_type(::Type{<:View})\n\nThe \"main type\" of the view: converts Type{View1D_S_HostAllocated{Float64}} into Type{View{Float64, 1, LayoutStride, HostSpace}}, which is easier to understand.\n\nThe opposite of impl_view_type.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.cxx_type_name","page":"Views","title":"Kokkos.Views.cxx_type_name","text":"cxx_type_name(::Type{<:View}, mangled::Bool = false)\ncxx_type_name(::View, mangled::Bool = false)\n\nReturn as a String the name of the exact C++ type wrapped by the given view type.\n\nIf mangled is true, then the mangled type name is returned. This name is compiler-dependant.\n\njulia> view_t = Kokkos.View{Float64, 2, Kokkos.LayoutRight, Kokkos.HostSpace}\nKokkos.Views.View{Float64, 2, Kokkos.Views.LayoutRight, Kokkos.HostSpace}\n\njulia> Kokkos.Views.cxx_type_name(view_t)\n\"Kokkos::View<double**, Kokkos::LayoutRight, Kokkos::Device<Kokkos::OpenMP, Kokkos::HostSpace>, Kokkos::MemoryTraits<0> >\"\n\njulia> Kokkos.Views.cxx_type_name(view_t, true)\n\"N6Kokkos4ViewIPPdJNS_11LayoutRightENS_6DeviceINS_6OpenMPENS_9HostSpaceEEENS_12MemoryTraitsILj0EEEEEE\"\n\nThis function relies on Dynamic Compilation.\n\n\n\n\n\n","category":"function"},{"location":"views/#Layouts","page":"Views","title":"Layouts","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"Layout\nLayoutLeft\nLayoutRight\nLayoutStride","category":"page"},{"location":"views/#Kokkos.Layout","page":"Views","title":"Kokkos.Layout","text":"Layout\n\nAbstract super-type of all view layouts.\n\nSub-types:\n\nLayoutLeft\nLayoutRight\nLayoutStride\n\n\n\n\n\n","category":"type"},{"location":"views/#Kokkos.LayoutLeft","page":"Views","title":"Kokkos.LayoutLeft","text":"LayoutLeft\n\nFortran-style column major array layout. This is also the layout of Julia arrays.\n\nWhile indexing, the first index is the contiguous one: v[i0, i1, i2].\n\nEquivalent to Kokkos::LayoutLeft.\n\n\n\n\n\n","category":"type"},{"location":"views/#Kokkos.LayoutRight","page":"Views","title":"Kokkos.LayoutRight","text":"LayoutRight\n\nC-style row major array layout.\n\nWhile indexing, the last index is the contiguous one: v[i2, i1, i0].\n\nEquivalent to Kokkos::LayoutRight.\n\n\n\n\n\n","category":"type"},{"location":"views/#Kokkos.LayoutStride","page":"Views","title":"Kokkos.LayoutStride","text":"LayoutStride\n\nArbitrary array layout, mostly used for sub-views.\n\nEquivalent to Kokkos::LayoutStride.\n\nWhen building a new view with a LayoutStride, the strides of each dimension must be given to the view constructor:\n\n# A 711 matrix with column-major layout\nv = Kokkos.View{Float64}(undef, 7, 11; layout=LayoutStride(1, 11))\n\n# A 711 matrix with row-major layout\nv = Kokkos.View{Float64}(undef, 7, 11; layout=LayoutStride(7, 1))\n\nThis differs slightly from the C++ Kokkos constructor, where dimensions and strides are interleaved.\n\n\n\n\n\n","category":"type"},{"location":"views/#Constants","page":"Views","title":"Constants","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"Idx","category":"page"},{"location":"views/#Kokkos.Idx","page":"Views","title":"Kokkos.Idx","text":"Idx::Type{<:Integer}\n\nInteger type used by views for indexing on the default execution space. Usually either Cint or Clonglong: a 32bit or 64bit signed integer.\n\nEquivalent to Kokkos::RangePolicy<>::index_type.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"CurrentModule = Kokkos","category":"page"},{"location":"calling_c/#Calling-a-Kokkos-library","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"","category":"section"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Suppose we want to wrap the following function:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"// my_lib.cpp\n#include \"Kokkos_Core.hpp\"\n\nextern \"C\"\nvoid fill_view(Kokkos::View<double*>& view, double value)\n{\n    Kokkos::parallel_for(Kokkos::RangePolicy<>(0, view.size()),\n    KOKKOS_LAMBDA(int i) {\n        view[i] = value;\n    });\n}","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"It is important to understand that here the argument type Kokkos::View<double*>& relies on the default template arguments for the layout type, memory space and memory traits. Therefore, its complete type will change depending on the Kokkos configuration.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"In order for Kokkos.jl to properly call this function, we must build a view from Julia whose type matches exactly the complete type of Kokkos::View<double*>.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"The View type represents such a complete view type. Its default parameters should match with those of our library, at the condition that Kokkos is configured in the same way. To achieve this you have two options:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"let Kokkos.jl configure the library and itself, guaranteeing that the options match\nthe library containing the function is already compiled, or you cannot/don't want to change its Kokkos configuration: you must configure Kokkos.jl with the exact same options","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"When calling a Kokkos method for the first time in a Julia session, Kokkos.jl will compile the C++ method into a shared library, which is then loaded with CxxWrap.jl to be used as a Julia method. See this chapter for more info about Dynamic Compilation.","category":"page"},{"location":"calling_c/#Your-CMake-project","page":"Calling a Kokkos library","title":"Your CMake project","text":"","category":"section"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"The CMake project shouldn't need extra handling to be compatible:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"# CMakeLists.txt\ncmake_minimum_required(VERSION 3.20)\nproject(MyLib)\n\n# set(BUILD_SHARED_LIBS ON)  # Not mandatory, Kokkos.jl can add it automatically\n\nfind_package(Kokkos REQUIRED)\n\nadd_library(MyLib SHARED my_lib.cpp)\ntarget_link_libraries(MyLib PRIVATE Kokkos::kokkos)  # or PUBLIC, it doesn't matter","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"find_package requires the Kokkos_ROOT (or Kokkos_DIR) variable to be set when configuring the project. Kokkos.jl can do that for you. The advantage of this approach is that your project and Kokkos.jl will share the same Kokkos installation, reducing the compilation time.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"If your project uses Kokkos in-tree, you have several options:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"keep the call to add_subdirectory the same, and configure kokkos_path to use the same path\nuse find_package if Kokkos_ROOT is defined:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"if (NOT DEFINED Kokkos_ROOT)\n    add_subdirectory(your/kokkos/path lib/kokkos)  # Use Kokkos in-tree\nelse()\n    find_package(Kokkos REQUIRED)  # Use the provided Kokkos installation\nendif()","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Be aware that using another Kokkos installation from the one used by Kokkos.jl might lead to obscure runtime/link time errors. A good first indicator of this issue would be the CMake warning that Kokkos_ROOT was not used by the project.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"warning: Warning\nAll libraries should use Kokkos as a shared library. To do this the cmake option \"BUILD_SHARED_LIBS\" must be \"ON\". Failing to do so will statically link Kokkos to your library, which therefore will not share the same environment as the kokkos wrapper library. This error is invisible in most backends but will create errors in others (like Cuda). When creating a project with a CMakeKokkosProject, \"BUILD_SHARED_LIBS\" will be properly set to \"ON\".","category":"page"},{"location":"calling_c/#Loading-the-wrapper-library-of-Kokkos.jl","page":"Calling a Kokkos library","title":"Loading the wrapper library of Kokkos.jl","text":"","category":"section"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Kokkos.jl relies on a wrapper library written in C++ to compile the basic functions of Kokkos, spaces related methods and backend-specific functions. It is configured through the Configuration Options.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Upon loading Kokkos.jl, this wrapper library is not loaded (and maybe not compiled). Therefore, most Kokkos functions will not work (some methods might be missing, others will raise an error).","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"To load the wrapper library you can use Kokkos.load_wrapper_lib or Kokkos.initialize:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> using Kokkos\n\njulia> Kokkos.load_wrapper_lib()  # Will compile then load the library, it may take some time\n\njulia> Kokkos.initialize()  # Will also call `Kokkos.load_wrapper_lib()` if needed\n","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"note: Note\nThe reason the wrapper library is not loaded when using Kokkos, is for setting the Configuration Options. After Kokkos.load_wrapper_lib() has been called, the configuration options are locked, and require to restart the Julia session for changes to be applied.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"note: Note\nSetting the environment variable JULIA_DEBUG to Kokkos will print all steps and commands called to compile and load the wrapper library, as well as for user libraries.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"note: Note\nUpon closing the Julia session, Kokkos.finalize will be called if needed.","category":"page"},{"location":"calling_c/#Compiling-and-loading-the-library","page":"Calling a Kokkos library","title":"Compiling and loading the library","text":"","category":"section"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"By default, when loading Kokkos.jl the build files will be stored in a scratch directory, this can be configured with build_dir. It is recommended to build the project files to the same directory, by using the Kokkos.KOKKOS_BUILD_DIR variable. In order for the Configuration Options to be passed correctly, you should use a CMakeKokkosProject:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> my_lib_path = \"./path/to/mylib/project\"\n\"./path/to/mylib/project\"\n\njulia> my_lib_build_path = joinpath(Kokkos.KOKKOS_BUILD_DIR, \"mylib\")\n\"/path/to/scratch/.kokkos-build/mylib\"\n\njulia> project = CMakeKokkosProject(my_lib_path, \"libMyLib\";\n                                    target=\"MyLib\", build_dir=my_lib_build_path)\nKokkos project from sources located at './path/to/mylib/project'\nBuilding in '/path/to/scratch.kokkos-build/mylib'\n...","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"If target is not given, CMakeKokkosProject will build by default all targets of the CMake project. Here \"libMyLib\" is the name of the result of the MyLib target: the library we want to compile and load.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> compile(project)\n\njulia> my_lib = load_lib(project)\nCLibrary(...)","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"The library can then be used the same way as you would with a shared library. Use handle to get a pointer to pass to Libdl.dlsym or use get_symbol to get the address of our fill_view function:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> v = Kokkos.View{Float64}(undef, 10)\n10-element Kokkos.Views.View{Float64, 1, Kokkos.LayoutRight, Kokkos.HostSpace}:\n 6.365987373e-314\n 1.14495326e-316\n...\n\njulia> ccall(get_symbol(my_lib, :fill_view),\n             Cvoid, (Ref{Kokkos.View}, Float64),\n             v, 0.1)\n\njulia> v\n10-element Kokkos.Views.View{Float64, 1, Kokkos.LayoutRight, Kokkos.HostSpace}:\n 0.1\n 0.1\n...","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Here we called void fill_view(Kokkos::View<double>&, double), which has been compiled with a single set of template arguments for Kokkos::View. Therefore the ccall is only valid if the view passed to it matches exactly those template arguments. You can further specify the argument types of the ccall to reflect this:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> ccall(get_symbol(my_lib, :fill_view),\n             Cvoid, (Ref{Kokkos.View{Float64, 1, Kokkos.DEFAULT_DEVICE_MEM_SPACE}}, Float64),\n             v, 0.1)","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"The library is opened in a way which allows it to be unloaded afterward using unload_lib:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> unload_lib(my_lib)\ntrue\n\njulia> is_lib_loaded(my_lib)\nfalse","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"This can be useful in order to reconfigure and recompile the project in the same session, to perform compilation parameters exploration for example. As long as all views are allocated through Kokkos.jl, they can be safely re-used after a library reload.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"warning: Warning\nThe full types of views (such as Kokkos.Views.Impl1.View1D_R_HostAllocated{Float64}) is ugly and can change from one session to another. Do not rely on such types.Use Views.main_view_type to get a more pleasant and stable type:julia> Kokkos.main_view_type(v)  # or `Kokkos.main_view_type(typeof(v))`\nKokkos.Views.View{Float64, 1, Kokkos.LayoutRight, Kokkos.HostSpace}","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"warning: Warning\nIf any view which has been allocated by an external library is owned by Julia (i.e. in the case where it is Julia which should call the destructor), it must be finalized before unloading the library (i.e. either finalize must be called on the view, or the garbage collector did so automatically beforehand).Failure to do so will result in nasty segfaults when the GC tries to call the finalizer on the view, which also happens when Julia is exiting.The segfault could look like this:signal (11): Segmentation error\nin expression starting at /home/Kokkos/test/runtests.jl:19\nunknown function (ip: 0x7f928f488090)\n_ZN6Kokkos4Impl22SharedAllocationRecordIvvE9decrementEPS2_ at /home/Kokkos/.kokkos-build/wrapper-build-release/lib/kokkos/core/src/libkokkoscore.so.4.0 (unknown line)The main clue that it is a finalizer error is the fact it happens in Kokkos::Impl::SharedAllocationRecord::decrement.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Kokkos","category":"page"},{"location":"#Kokkos.jl","page":"Home","title":"Kokkos.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Kokkos.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kokkos.jl allows you to create Kokkos::View instances from Julia, to configure and compile a Kokkos project or load an existing library, and call its functions and the Kokkos kernels it defines.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kokkos.jl supports all backends of Kokkos.","category":"page"},{"location":"","page":"Home","title":"Home","text":"View inherits the AbstractArray interface of Julia, and can therefore be used as a normal Array. All view accesses are done through calls to Kokkos::View::operator(), and therefore can access CPU or GPU memory seamlessly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nCurrently Kokkos.jl does not create Kokkos kernels (e.g. using Kokkos::parallel_for) since it would require automatic Julia to C++ code convertion. You also cannot run Julia code in Kokkos kernels, since Julia cannot be used in threads it doesn't own (or adopted, in Julia 1.9).","category":"page"}]
}
