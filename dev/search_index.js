var documenterSearchIndex = {"docs":
[{"location":"environment/","page":"Environment","title":"Environment","text":"CurrentModule = Kokkos","category":"page"},{"location":"environment/#Environment","page":"Environment","title":"Environment","text":"","category":"section"},{"location":"environment/#Initialization","page":"Environment","title":"Initialization","text":"","category":"section"},{"location":"environment/","page":"Environment","title":"Environment","text":"initialize\nis_initialized\nfinalize\nis_finalized\nload_wrapper_lib\nis_kokkos_wrapper_loaded","category":"page"},{"location":"environment/#Kokkos.initialize","page":"Environment","title":"Kokkos.initialize","text":"initialize(;\n    num_threads=nothing,\n    device_id=nothing, map_device_id_by=nothing,\n    disable_warnings=nothing, print_configuration=nothing,\n    tune_internals=nothing,\n    tools_libs=nothing, tools_args=nothing\n)\n\nInitializes Kokkos by calling Kokkos::initialize().\n\nThe keyword arguments build are passed to the InitializationSettings constructor which is then passed to Kokkos::initialize(). A value of nothing keeps the default behaviour of Kokkos.\n\nThe Kokkos wrapper library is loaded (and recompiled if needed) if it is not already the case. This locks the current Configuration Options until the end of the current Julia session.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.is_initialized","page":"Environment","title":"Kokkos.is_initialized","text":"is_initialized()\n\nReturn Kokkos::is_initialized().\n\nCan be called before the wrapper library is loaded.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.finalize","page":"Environment","title":"Kokkos.finalize","text":"finalize()\n\nCalls Kokkos::finalize().\n\nwarning: Warning\nKokkos requires that all view destructors should be called before calling finalize.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.is_finalized","page":"Environment","title":"Kokkos.is_finalized","text":"is_finalized()\n\nReturn Kokkos::is_finalized().\n\nCan be called before the wrapper library is loaded.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.KokkosWrapper.load_wrapper_lib","page":"Environment","title":"Kokkos.KokkosWrapper.load_wrapper_lib","text":"load_wrapper_lib(; no_compilation=false, no_git=false, loading_bar=true)\n\nConfigures, compiles then loads the wrapper library using the current Configuration Options.\n\nAfter calling this method, all configuration options become locked.\n\nIf no_compilation is true, then the CMake project of the wrapper library will not be configured or compiled.\n\nIf no_git is true, then if we need to use the Kokkos installation of the package, no Git operations (clone + checkout) will be done.\n\nBoth no_compilation=true and no_git=true are needed when initializing Kokkos.jl in non-root MPI processes.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.is_kokkos_wrapper_loaded","page":"Environment","title":"Kokkos.is_kokkos_wrapper_loaded","text":"is_kokkos_wrapper_loaded()\n\nReturn true if load_wrapper_lib has been called.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Configuration","page":"Environment","title":"Configuration","text":"","category":"section"},{"location":"environment/","page":"Environment","title":"Environment","text":"build_in_scratch\nbuild_in_tmp\nbuild_in_project\nrequire\nconfiginfo\nversioninfo\nprint_configuration\nset_omp_vars","category":"page"},{"location":"environment/#Kokkos.build_in_scratch","page":"Environment","title":"Kokkos.build_in_scratch","text":"build_in_scratch()\n\nSets the build_dir configuration option to a scratch directory (the default).\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.build_in_tmp","page":"Environment","title":"Kokkos.build_in_tmp","text":"build_in_tmp()\n\nSets the build_dir configuration option to a temporary directory, cleaned at the end of the Julia session.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.build_in_project","page":"Environment","title":"Kokkos.build_in_project","text":"build_in_project(name = \".kokkos-build\")\n\nSets the build_dir configuration option to the directory name in the active project directory.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.require","page":"Environment","title":"Kokkos.require","text":"require(;\n    version=nothing,\n    dims=nothing, types=nothing, layouts=nothing,\n    idx=nothing,\n    exec_spaces=nothing, mem_spaces=nothing,\n    no_error=false\n)\n\nAsserts that the underlying Kokkos wrapper library of Kokkos.jl respects the given requirements.\n\nAn argument with a value of nothing is considered to have no requirements.\n\nversion checks for the version of Kokkos.\n\nidx checks the type of the index variables used when accessing a view.\n\nversion and idx are given as callables returning a Bool and taking a single argument: respectively a VersionNumber and a Type, e.g. passing version = >=(v\"4.0.0\") will match all Kokkos versions including v4.0.0 and above.\n\ndims, types, layouts, exec_spaces and mem_spaces are lists of the required values. \n\ndims, types and layouts check the available dimensions, types and layouts of views, while exec_spaces and mem_spaces do the same for execution and memory spaces.\n\nIf no_error is true, then this function will return false if any requirement is not met.\n\nThis function does not require for Kokkos to be initialized, but for the wrapper library to be loaded. If the wrapper is not loaded, the configuration options will be checked instead, however they cannot cover all possible requirements (idx and mem_spaces do not work and version works only if the packaged Kokkos installation is used).\n\nExamples\n\n# Require Kokkos version 4.0.0 (exactly), and for 1D and 2D views of Float64 to be compiled with\n# a column or row major layout:\nKokkos.require(;\n    version = ==(v\"4.0.0\"),\n    types = [Float64],\n    dims = [1, 2],\n    layouts = [Kokkos.LayoutLeft, Kokkos.LayoutRight]    \n)\n\n# Require an index type of 8 bytes, the Cuda and OpenMP backends of Kokkos, as well as the Cuda UVM\n# memory space to be available:\nKokkos.require(;\n    idx = (==(8) âˆ˜ sizeof),\n    exec_spaces = [Kokkos.Cuda, Kokkos.OpenMP],\n    mem_spaces = [Kokkos.CudaUVMSpace]\n)\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.configinfo","page":"Environment","title":"Kokkos.configinfo","text":"configinfo(io::IO = stdout)\n\nPrint information about all configuration options.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.versioninfo","page":"Environment","title":"Kokkos.versioninfo","text":"versioninfo(io::IO = stdout; internal=true, verbose=false)\n\nPrint the version and various information about the underlying Kokkos library.\n\nIf internal is true, Kokkos::print_configuration() is called. verbose is passed to that call.\n\nThis function does not require for Kokkos to be initialized, however if internal=true then the output will be incomplete.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.print_configuration","page":"Environment","title":"Kokkos.print_configuration","text":"print_configuration(io::IO, verbose::Bool)\n\nPrints the internal Kokkos configuration to io.\n\nEquivalent to Kokkos::print_configuration(out, verbose).\n\n\n\n\n\n","category":"function"},{"location":"environment/#Kokkos.set_omp_vars","page":"Environment","title":"Kokkos.set_omp_vars","text":"set_omp_vars(;\n    places = \"cores\",\n    bind = \"close\",\n    num_threads = Threads.nthreads()\n)\n\nHelper function to set the main OpenMP environment variables used by Kokkos. It must be called before calling initialize.\n\nplaces sets OMP_PLACES. bind sets OMP_PROC_BIND. num_threads sets OMP_NUM_THREADS.\n\nNote that since Julia threads and OpenMP threads are decoupled, there is no constraint imposed by Julia on OpenMP threads: there can be as many threads as needed.\n\nwarning: Warning\nPinning the Julia threads with ThreadPinning.jl or with the JULIA_EXCLUSIVE environment variable can have an impact on OpenMP thread affinities, making the OpenMP variables useless.\n\n\n\n\n\n","category":"function"},{"location":"environment/#Synchronization","page":"Environment","title":"Synchronization","text":"","category":"section"},{"location":"environment/","page":"Environment","title":"Environment","text":"fence","category":"page"},{"location":"environment/#Kokkos.fence","page":"Environment","title":"Kokkos.fence","text":"fence()\nfence(label::String)\n\nWait for all asynchronous Kokkos operations to complete.\n\nEquivalent to Kokkos::fence().\n\n\n\n\n\n","category":"function"},{"location":"environment/#Constants","page":"Environment","title":"Constants","text":"","category":"section"},{"location":"environment/","page":"Environment","title":"Environment","text":"KOKKOS_VERSION","category":"page"},{"location":"environment/#Kokkos.KOKKOS_VERSION","page":"Environment","title":"Kokkos.KOKKOS_VERSION","text":"KOKKOS_VERSION::VersionNumber\n\nThe Kokkos version currently loaded.\n\nnothing if Kokkos is not yet loaded. See kokkos_version for the version of the packaged installation of Kokkos, which is defined before loading Kokkos.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"CurrentModule = Kokkos.Spaces","category":"page"},{"location":"spaces/#Execution-and-Memory-Spaces","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"Space\nExecutionSpace\nMemorySpace\naccessible(::Serial, ::HostSpace)\narray_layout(::Space)\nenabled\nexecution_space\nmemory_space(::Space)\nmain_space_type\nimpl_space_type\nkokkos_name\nfence(::ExecutionSpace)\nconcurrency\nallocate\ndeallocate","category":"page"},{"location":"spaces/#Kokkos.Spaces.Space","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.Space","text":"Space\n\nAbstract super type of all execution and memory spaces.\n\nMain subtypes:\n\nExecutionSpaces: super type of all execution spaces\nMemorySpaces: super type of all memory spaces\n\nAll Kokkos spaces have a main abstract type (Serial, Cuda, HostSpace, HIPSpace...) which are defined even if it has not been compiled on the C++ side. Those main abstract types should be the ones used when specifying a space. This allows methods like enabled to work independently from the compiled internal library.\n\nWhen a space is compiled, a sub-type of its main type is defined by CxxWrap, leading to the following type structure: SerialImplAllocated <: SerialImpl <: Serial <: ExecutionSpace <: Space. Below the main space type (here, Serial), the sub-types are only defined if they are compiled, and therefore they should not be relied upon. \n\nNavigating the type tree can be made easier through main_space_type.\n\n\n\n\n\n","category":"type"},{"location":"spaces/#Kokkos.Spaces.ExecutionSpace","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.ExecutionSpace","text":"ExecutionSpace <: Space\n\nAbstract super-type of all execution spaces.\n\nSub-types:\n\nSerial\nOpenMP\nOpenACC\nOpenMPTarget\nThreads\nCuda\nHIP\nHPX\nSYCL\n\nAll sub-types are always defined, but only some of them are enabled. To enable an execution space, you must enable its related Kokkos backend, e.g. \"-DKokkos_ENABLE_SERIAL=ON\" for the Serial execution space.\n\nTo do this you can set the backends option with Kokkos.set_backends, or specify the option directly through kokkos_options.\n\n\n\n\n\n","category":"type"},{"location":"spaces/#Kokkos.Spaces.MemorySpace","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.MemorySpace","text":"MemorySpace <: Space\n\nAbstract super-type of all memory spaces.\n\nSub-types:\n\nHostSpace\nCudaSpace\nCudaHostPinnedSpace\nCudaUVMSpace\nHIPSpace\nHIPHostPinnedSpace\nHIPManagedSpace\n\nSub-types work the same as for ExecutionSpace. They can be enabled by enabling their respective backend.\n\n\n\n\n\n","category":"type"},{"location":"spaces/#Kokkos.Spaces.accessible-Tuple{Kokkos.Spaces.Serial, Kokkos.Spaces.HostSpace}","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.accessible","text":"accessible([S1::Union{<:Space, Type{<:Space}},] S2::Union{<:MemorySpace, Type{<:MemorySpace}})\n\nReturn true if the memory space S2 is accessible from S1 (a memory or execution space).\n\nIf only S2 is specified, S1 defaults to DEFAULT_HOST_SPACE.\n\nEquivalent to Kokkos::SpaceAccessibility<S1, S2>::accessible\n\n\n\n\n\n","category":"method"},{"location":"spaces/#Kokkos.Spaces.array_layout-Tuple{Kokkos.Spaces.Space}","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.array_layout","text":"array_layout(exec_space::Union{<:ExecutionSpace, Type{<:ExecutionSpace}})\n\nReturn the default array layout type of the given execution space.\n\n\n\n\n\n","category":"method"},{"location":"spaces/#Kokkos.Spaces.enabled","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.enabled","text":"enabled(space::Union{Space, Type{<:Space}})\n\nReturn true if the given execution or memory space is compiled.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.execution_space","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.execution_space","text":"execution_space(space::Union{<:MemorySpace, Type{<:MemorySpace}})\n\nReturn the execution space associated by default to the given memory space.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.memory_space-Tuple{Kokkos.Spaces.Space}","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.memory_space","text":"memory_space(space::Union{<:ExecutionSpace, Type{<:ExecutionSpace}})\n\nReturn the memory space associated by default to the given execution space.\n\n\n\n\n\n","category":"method"},{"location":"spaces/#Kokkos.Spaces.main_space_type","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.main_space_type","text":"main_space_type(space::Union{<:Space, Type{<:Space}})\n\nReturn the main space type of space, e.g. for Serial, SerialImpl or SerialImplAllocated we get Serial.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.impl_space_type","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.impl_space_type","text":"impl_space_type(::Type{<:Space})\n\nOpposite of main_space_type: from the main space type (Serial, OpenMP, HostSpace...) return the implementation type (SerialImpl, OpenMPImpl, HostSpaceImpl...). The given space must be compiled.\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.kokkos_name","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.kokkos_name","text":"kokkos_name(space::Union{Space, Type{<:Space}})\n\nReturn the name of the execution or memory space as defined by Kokkos.\n\nEquivalent to Kokkos::space::name()\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.fence-Tuple{Kokkos.Spaces.ExecutionSpace}","page":"Execution & Memory Spaces","title":"Kokkos.fence","text":"fence(exec_space::ExecutionSpace)\n\nWait for all asynchronous tasks operating on this execution space instance to complete.\n\nEquivalent to exec_space.fence().\n\n\n\n\n\n","category":"method"},{"location":"spaces/#Kokkos.Spaces.concurrency","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.concurrency","text":"concurrency(exec_space::ExecutionSpace)\n\nThe maximum number of threads utilized by the execution space instance.\n\nEquivalent to exec_space.concurrency().\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.allocate","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.allocate","text":"allocate(mem_space::MemorySpace, bytes)\n\nAllocate bytes on the memory space instance. Returns a pointer to the allocated memory.\n\nEquivalent to mem_space.allocate(bytes)\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.deallocate","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.deallocate","text":"deallocate(mem_space::MemorySpace, ptr)\n\nFrees ptr, previously allocated with allocate.\n\nEquivalent to mem_space.deallocate(ptr, bytes)\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Constants","page":"Execution & Memory Spaces","title":"Constants","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"COMPILED_EXEC_SPACES\nCOMPILED_MEM_SPACES","category":"page"},{"location":"spaces/#Kokkos.Spaces.COMPILED_EXEC_SPACES","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.COMPILED_EXEC_SPACES","text":"COMPILED_EXEC_SPACES::Tuple{Vararg{Type{<:ExecutionSpace}}}\n\nList of all compiled Kokkos execution spaces.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.Spaces.COMPILED_MEM_SPACES","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.COMPILED_MEM_SPACES","text":"COMPILED_MEM_SPACES::Tuple{Vararg{Type{<:MemorySpace}}}\n\nList of all compiled Kokkos execution spaces.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Default-spaces","page":"Execution & Memory Spaces","title":"Default spaces","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"DEFAULT_DEVICE_SPACE\nDEFAULT_DEVICE_MEM_SPACE\nDEFAULT_HOST_SPACE\nDEFAULT_HOST_MEM_SPACE\nSHARED_MEMORY_SPACE\nSHARED_HOST_PINNED_MEMORY_SPACE","category":"page"},{"location":"spaces/#Kokkos.Spaces.DEFAULT_DEVICE_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.DEFAULT_DEVICE_SPACE","text":"DEFAULT_DEVICE_SPACE::Type{<:ExecutionSpace}\n\nThe default execution space where kernels are applied on the device.\n\nEquivalent to Kokkos::DefaultExecutionSpace.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.Spaces.DEFAULT_DEVICE_MEM_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.DEFAULT_DEVICE_MEM_SPACE","text":"DEFAULT_DEVICE_MEM_SPACE::Type{<:MemorySpace}\n\nThe default memory space where views are stored on the device.\n\nEquivalent to Kokkos::DefaultExecutionSpace::memory_space.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.Spaces.DEFAULT_HOST_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.DEFAULT_HOST_SPACE","text":"DEFAULT_HOST_SPACE::Type{<:ExecutionSpace}\n\nThe default execution space where kernels are applied on the host.\n\nEquivalent to Kokkos::DefaultHostExecutionSpace.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.Spaces.DEFAULT_HOST_MEM_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.DEFAULT_HOST_MEM_SPACE","text":"DEFAULT_HOST_MEM_SPACE::Type{<:MemorySpace}\n\nThe default memory space where views are stored on the host.\n\nEquivalent to Kokkos::DefaultHostExecutionSpace::memory_space.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.Spaces.SHARED_MEMORY_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.SHARED_MEMORY_SPACE","text":"SHARED_MEMORY_SPACE::Union{Nothing, Type{<:MemorySpace}}\n\nThe shared memory space between the host and device, or nothing if there is none.\n\nEquivalent to Kokkos::SharedSpace if Kokkos::has_shared_space is true.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Kokkos.Spaces.SHARED_HOST_PINNED_MEMORY_SPACE","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.SHARED_HOST_PINNED_MEMORY_SPACE","text":"SHARED_HOST_PINNED_MEMORY_SPACE::Union{Nothing, Type{<:MemorySpace}}\n\nThe shared pinned memory space between the host and device, or nothing if there is none.\n\nEquivalent to Kokkos::SharedHostPinnedSpace if Kokkos::has_shared_host_pinned_space is true.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"spaces/#Backend-specific-methods","page":"Execution & Memory Spaces","title":"Backend-specific methods","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"Those unexported methods are defined in the Kokkos.Spaces.BackendFunctions module. They have methods only if their respective backend is enabled and Kokkos is initialized.","category":"page"},{"location":"spaces/#OpenMP","page":"Execution & Memory Spaces","title":"OpenMP","text":"","category":"section"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"Some functions of the OpenMP runtime are made available through Kokkos.jl, mostly for debugging purposes and tracking thread affinity.","category":"page"},{"location":"spaces/","page":"Execution & Memory Spaces","title":"Execution & Memory Spaces","text":"BackendFunctions.omp_set_num_threads\nBackendFunctions.omp_get_max_threads\nBackendFunctions.omp_get_proc_bind\nBackendFunctions.omp_get_num_places\nBackendFunctions.omp_get_place_num_procs\nBackendFunctions.omp_get_place_proc_ids\nBackendFunctions.omp_capture_affinity","category":"page"},{"location":"spaces/#Kokkos.Spaces.BackendFunctions.omp_set_num_threads","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.BackendFunctions.omp_set_num_threads","text":"omp_set_num_threads(threads::Cint)::Cvoid\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.BackendFunctions.omp_get_max_threads","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.BackendFunctions.omp_get_max_threads","text":"omp_get_max_threads()::Cint\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.BackendFunctions.omp_get_proc_bind","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.BackendFunctions.omp_get_proc_bind","text":"omp_get_proc_bind()::Cint\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.BackendFunctions.omp_get_num_places","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.BackendFunctions.omp_get_num_places","text":"omp_get_num_places()::Cint\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.BackendFunctions.omp_get_place_num_procs","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.BackendFunctions.omp_get_place_num_procs","text":"omp_get_place_num_procs(place::Cint)::Cint\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.BackendFunctions.omp_get_place_proc_ids","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.BackendFunctions.omp_get_place_proc_ids","text":"omp_get_place_proc_ids(place::Cint)::Vector{Cint}\n\nSee the OpenMP docs\n\n\n\n\n\n","category":"function"},{"location":"spaces/#Kokkos.Spaces.BackendFunctions.omp_capture_affinity","page":"Execution & Memory Spaces","title":"Kokkos.Spaces.BackendFunctions.omp_capture_affinity","text":"omp_capture_affinity([format::String])::String\n\nMore or less equivalent to  omp_display_affinity(char*), but applies the given format (or OpenMP's default one) to each OpenMP thread using  omp_capture_affinity, and returns the result.\n\n\n\n\n\n","category":"function"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"CurrentModule = Kokkos","category":"page"},{"location":"config_options/#Configuration-Options","page":"Configuration options","title":"Configuration Options","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Configuration options are set using Preferences.jl. Your LocalPreferences.jl file will store the options needed by your current project in a [Kokkos] section.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"danger: Important\nUnlike some packages using Preferences.jl, it is possible to change all options during the same Julia session, using their setters. However, if you need to dynamically configure Kokkos.jl, it must be done before loading the wrapper library. After calling load_wrapper_lib (or initialize), all options will be locked, and any changes made afterward will not affect the current Julia session.","category":"page"},{"location":"config_options/#kokkos_version","page":"Configuration options","title":"kokkos_version","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The version of Kokkos to use. Must be a valid version tag in the official Kokkos repository (e.g. \"4.0.00\").","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Only used when kokkos_path is not set, and defaults to the one of the packaged sources of kokkos.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Each version is stored in the package's scratch space, which is checked-out upon loading the Kokkos.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_kokkos_version(). The value for the current Julia session is stored in Kokkos.LOCAL_KOKKOS_VERSION_STR.","category":"page"},{"location":"config_options/#kokkos_path","page":"Configuration options","title":"kokkos_path","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The path to the Kokkos sources (not an installation!) to use. If not set, it defaults to the Kokkos version packaged with Kokkos.jl.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_kokkos_path(). The value for the current Julia session is stored in Kokkos.KOKKOS_PATH.","category":"page"},{"location":"config_options/#cmake_options","page":"Configuration options","title":"cmake_options","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The list of CMake options to pass to all CMakeKokkosProjects.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_cmake_options(). The value for the current Julia session is stored in Kokkos.KOKKOS_CMAKE_OPTIONS.","category":"page"},{"location":"config_options/#kokkos_options","page":"Configuration options","title":"kokkos_options","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The list of Kokkos options to pass to all KokkosProjects.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"It can be passed as a list of \"Kokkos_<option_name>=<value>\", or as a Dict{String, Any} (Bool values will be converted to \"ON\" and \"OFF\", others to strings).","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_kokkos_options(). The value for the current Julia session is stored in Kokkos.KOKKOS_LIB_OPTIONS.","category":"page"},{"location":"config_options/#backends","page":"Configuration options","title":"backends","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The list of Kokkos backends to compile for. When in uppercase and prefixed by Kokkos_ENABLE_ the names should correspond to one of the valid device backends options. Defaults to Serial and OpenMP.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_backends(), using a vector of String or ExecutionSpace subtypes.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"The value for the current Julia session is stored in Kokkos.KOKKOS_BACKENDS.","category":"page"},{"location":"config_options/#view_dims","page":"Configuration options","title":"view_dims","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"List of Ints for which view dimensions will be compiled.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_view_dims(). The value for the current Julia session is stored in Kokkos.KOKKOS_VIEW_DIMS.","category":"page"},{"location":"config_options/#view_types","page":"Configuration options","title":"view_types","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"List of Types for which views will be compiled.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_view_types(), using a Vector of String or Type. The value for the current Julia session is stored in Kokkos.KOKKOS_VIEW_TYPES.","category":"page"},{"location":"config_options/#view_layouts","page":"Configuration options","title":"view_layouts","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"List of layouts for which views will be compiled. The following layouts are supported:","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"'left', for Kokkos::LayoutLeft\n'right', for Kokkos::LayoutRight\n'stride', for Kokkos::LayoutStride\n'deviceDefault', for the default layout of the default device execution space: Kokkos::DefaultExecutionSpace::array_layout\n'hostDefault', for the default layout of the default host execution space: Kokkos::DefaultHostExecutionSpace::array_layout","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_view_layouts(), using a Vector of String or Kokkos.Layout types. The value for the current Julia session is stored in Kokkos.KOKKOS_LAYOUT_TYPES.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Note that 'deviceDefault' and 'hostDefault' resolve to one of 'left', 'right' or 'stride', and appear as such through Kokkos.COMPILED_LAYOUTS.","category":"page"},{"location":"config_options/#build_type","page":"Configuration options","title":"build_type","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"CMake build type.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_build_type(). The value for the current Julia session is stored in Kokkos.KOKKOS_BUILD_TYPE.","category":"page"},{"location":"config_options/#build_dir","page":"Configuration options","title":"build_dir","text":"","category":"section"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Main building directory for the current session. The wrapping library is built in $(build_dir)/wrapper-build-$(build_type)/.","category":"page"},{"location":"config_options/","page":"Configuration options","title":"Configuration options","text":"Can be set using Kokkos.set_build_dir(), Kokkos.build_in_scratch, Kokkos.build_in_tmp or Kokkos.build_in_project. The value for the current Julia session is stored in Kokkos.KOKKOS_BUILD_DIR.","category":"page"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"CurrentModule = Kokkos","category":"page"},{"location":"compilation/#Compilation","page":"Compilation","title":"Compilation","text":"","category":"section"},{"location":"compilation/#Kokkos-Projects","page":"Compilation","title":"Kokkos Projects","text":"","category":"section"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"KokkosProject\nCMakeKokkosProject\nbuild_dir\nsource_dir\nlib_path\noptions\noption!\nconfiguration_changed\nconfiguration_changed!\nconfigure\ncompile\nclean","category":"page"},{"location":"compilation/#Kokkos.KokkosProject","page":"Compilation","title":"Kokkos.KokkosProject","text":"KokkosProject\n\nAbstract type representing a C++ project using Kokkos, where it is located and how to compile it using which options.\n\n\n\n\n\n","category":"type"},{"location":"compilation/#Kokkos.CMakeKokkosProject","page":"Compilation","title":"Kokkos.CMakeKokkosProject","text":"CMakeKokkosProject(source_dir, target_lib_path;\n    target = \"all\",\n    build_type = \"Release\",\n    build_dir = joinpath(source_dir, \"cmake-build-$(lowercase(build_type))\"),\n    cmake_options = [],\n    kokkos_path = nothing,\n    kokkos_options = nothing,\n    inherit_options = true\n)\n\nConstruct a new Kokkos project in source_dir built to build_dir using CMake. After compilation, the target library should be found at joinpath(build_dir, target_lib_path).\n\nThe shared library extension of target_lib_path can be omitted, as it is added if needed by Libdl.dlopen.\n\ntarget is the CMake target needed to build the library.\n\nbuild_type controls the CMAKE_BUILD_TYPE variable, and cmake_options contains all other options passed to each CMake command.\n\nkokkos_path sets the Kokkos_ROOT CMake variable, to be used by find_package.\n\nkokkos_path should be left to nothing in most cases, as it will be replaced by the installation directory of Kokkos correctly configured with the current options (see get_kokkos_install_dir).\n\nwarning: Warning\nThe Kokkos version of the project must match the version used by the internal wrapper library. If this is not the case, the program may silently fail. Use the kokkos_path configuration variable to change the Kokkos version throughout Kokkos.jl.\n\nkokkos_options is a Dict of Kokkos variables needed to configure the project (see the docs). Values of type Bool are converted to \"ON\" and \"OFF\", all other types directly are converted to strings. Each variable is then passed to CMake as \"-D$(name)=$(value)\".\n\nIf inherit_options is true, the cmake_options of the Kokkos wrapper project will be appended at the front of the new project's cmake_options. kokkos_options are not inherited here since Kokkos's CMake mechanisms do this automatically.\n\nAll commands are invoked from the current working directory.\n\n\n\n\n\nCMakeKokkosProject(project::CMakeKokkosProject, target, target_lib_path)\n\nConstruct a project from another, for a different target.\n\nThe source and build directories will stay the same, and options will be copied.\n\n\n\n\n\n","category":"type"},{"location":"compilation/#Kokkos.build_dir","page":"Compilation","title":"Kokkos.build_dir","text":"build_dir(project::KokkosProject)\n\nReturn the build directory of project.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.source_dir","page":"Compilation","title":"Kokkos.source_dir","text":"source_dir(project::KokkosProject)\n\nReturn the source directory of project.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.lib_path","page":"Compilation","title":"Kokkos.lib_path","text":"lib_path(project::KokkosProject)\n\nReturn the path to the target library for project.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.options","page":"Compilation","title":"Kokkos.options","text":"options(project::KokkosProject)\n\nReturn the set of options to the target library for project.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.option!","page":"Compilation","title":"Kokkos.option!","text":"option!(project::KokkosProject, name::String, val; prefix=\"Kokkos_\")\n\nSets the given Kokkos option for the project to val. This will result in the following compilation option: \"-D$(prefix)$(name)=$(val)\".\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.configuration_changed","page":"Compilation","title":"Kokkos.configuration_changed","text":"configuration_changed(project::KokkosProject)\n\nReturn true if the configuration of project changed, and needs to be recompiled.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.configuration_changed!","page":"Compilation","title":"Kokkos.configuration_changed!","text":"configuration_changed!(project::KokkosProject, val::Bool = true)\n\nSets the configuration state of project to val.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.configure","page":"Compilation","title":"Kokkos.configure","text":"configure(project::KokkosProject)\n\nConfigure the project with its current options.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.compile","page":"Compilation","title":"Kokkos.compile","text":"compile(project::KokkosProject)\n\nBuilds all source files of the project.\n\nIf the project's configuration changed, it is reconfigured first.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.clean","page":"Compilation","title":"Kokkos.clean","text":"clean(project::KokkosProject; reset=false)\n\nClean the project, forcing a recompilation of all source files.\n\nIf reset == true, the entire build_dir is removed, therefore ensuring that no cached CMake variable can interfere with the build.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Utilities","page":"Compilation","title":"Utilities","text":"","category":"section"},{"location":"compilation/","page":"Compilation","title":"Compilation","text":"get_jlcxx_root\nget_kokkos_build_dir\nget_kokkos_dir\nget_kokkos_install_dir","category":"page"},{"location":"compilation/#Kokkos.KokkosWrapper.get_jlcxx_root","page":"Compilation","title":"Kokkos.KokkosWrapper.get_jlcxx_root","text":"get_jlcxx_root()\n\nReturn the directory where the file \"JlCxxConfig.cmake\" is located for the currently loaded CxxWrap package.\n\nSetting the CMake variable JlCxx_ROOT to this path allows the CMake function find_package to load JlCxx. \n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.KokkosWrapper.get_kokkos_build_dir","page":"Compilation","title":"Kokkos.KokkosWrapper.get_kokkos_build_dir","text":"get_kokkos_build_dir()\n\nThe directory where Kokkos is compiled.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.KokkosWrapper.get_kokkos_dir","page":"Compilation","title":"Kokkos.KokkosWrapper.get_kokkos_dir","text":"get_kokkos_dir()\n\nThe directory where the sources of Kokkos are located.\n\nIf KOKKOS_PATH is not set, it defaults to the sources of Kokkos packaged with Kokkos.jl.\n\nThis directory is meant to be passed to the CMake function add_subdirectory in order to load Kokkos as an in-tree build.\n\n\n\n\n\n","category":"function"},{"location":"compilation/#Kokkos.KokkosWrapper.get_kokkos_install_dir","page":"Compilation","title":"Kokkos.KokkosWrapper.get_kokkos_install_dir","text":"get_kokkos_install_dir()\n\nThe directory where Kokkos is installed.\n\nThis directory can be passed to the CMake function find_package through the Kokkos_ROOT variable in order to load Kokkos with the same options and backends as the ones used by Kokkos.jl.\n\n\n\n\n\n","category":"function"},{"location":"MPI/","page":"MPI","title":"MPI","text":"CurrentModule = Kokkos","category":"page"},{"location":"MPI/#Using-Kokkos.jl-with-MPI.jl","page":"MPI","title":"Using Kokkos.jl with MPI.jl","text":"","category":"section"},{"location":"MPI/#Loading-and-compilation","page":"MPI","title":"Loading and compilation","text":"","category":"section"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Since calling Kokkos.initialize may trigger the compilation of the internal wrapper library, some care is needed to make sure only a single process is compiling.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"A basic initialization workflow with MPI may look like this:","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"using MPI\nusing Kokkos\n\nMPI.Init()\n\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nif rank == 0\n    Kokkos.load_wrapper_lib()  # All compilation (if any) of the C++ wrapper happens here\nend\n\nMPI.Barrier(MPI.COMM_WORLD)\n\nrank != 0 && Kokkos.load_wrapper_lib(; no_compilation=true, no_git=true)\nKokkos.initialize()","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Note that passing no_compilation=true and no_git=true to load_wrapper_lib on the non-root processes is required.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"The same workflow can be used to compile your library on the root process:","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"my_project = CMakeKokkosProject(project_src, \"libproj\")\nrank == 0 && compile(my_project)\nMPI.Barrier(MPI.COMM_WORLD)\nlib = load_lib(my_project)","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"If configuration options need to be changed before initializing Kokkos, then it is preferable to perform the changes on the root process before using Kokkos is called on the others, since changing options will modify the LocalPreferrences.toml file.","category":"page"},{"location":"MPI/#Passing-views-to-MPI","page":"MPI","title":"Passing views to MPI","text":"","category":"section"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Passing a Kokkos.View to a MPI directive is possible:","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"v = View{Float64}(n)\nv .= MPI.Comm_rank(MPI.COMM_WORLD)\n\nr = View{Float64}(n)\n\nMPI.Sendrecv!(v, next_rank, 0, r, prev_rank, 0, MPI.COMM_WORLD)\n\n@assert all(r .== prev_rank)","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Internally, the pointer to the data of the view is passed to MPI, there is no copy of the data, regardless of the memory space where the view is stored in.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"If Kokkos.span_is_contiguous(view) == true, then the whole memory span of the view is passed to MPI as a single block of data.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"For non-contiguous views (such as LayoutStride), a custom MPI.Datatype is built to exactly represent the view.","category":"page"},{"location":"MPI/","page":"MPI","title":"MPI","text":"Support for GPU-awareness should be seamless, as long as your MPI implementation supports the GPU.","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"CurrentModule = Kokkos","category":"page"},{"location":"inaccessible_views/#Using-views-in-an-inaccessible-memory-space","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"","category":"section"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"By Kokkos semantics, it is not possible to read or write views which are stored in an inaccessible memory space (accessible(view) == false). Therefore views on a GPU device (stored in a CudaSpace, HIPSpace, etc...) cannot be displayed:","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"julia> v = Kokkos.View{Float64}(10; mem_space=Kokkos.CudaSpace)\n10-element Kokkos.KokkosWrapper.Impl.View1D_L_CudaAllocated{Float64}:\nError showing value of type Kokkos.KokkosWrapper.Impl.View1D_L_CudaAllocated{Float64}:\nERROR: the view is inaccessible from the default host execution space\n...","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"This can be viewed as a stricter version of allowscalar(false) in CUDA.jl or AMDGPU.jl.","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"The correct approch is the same as in C++: creating a host copy of the view.","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"julia> host_v = Kokkos.create_mirror_view(v; mem_space=Kokkos.HostSpace());\n\njulia> copyto!(host_v, v)  # Calls `Kokkos.deep_copy`\n\njulia> host_v\n10-element Kokkos.KokkosWrapper.Impl.View1D_L_HostAllocated{Float64}:\n 0.0\n 0.0\n 0.0\n...\n\njulia> host_v[1] = 1\n1\n\njulia> copyto!(v, host_v)\n","category":"page"},{"location":"inaccessible_views/","page":"Using views in an inaccessible memory space","title":"Using views in an inaccessible memory space","text":"The strength of this approach is the fact that it will be efficient whatever the device backend is. create_mirror_view will simply return the view passed to it if the memory space is the same, making it effectively a no-op. Same for deep_copy, which is a no-op if both arguments are the same.","category":"page"},{"location":"library_management/","page":"Library Management","title":"Library Management","text":"CurrentModule = Kokkos","category":"page"},{"location":"library_management/#Library-Management","page":"Library Management","title":"Library Management","text":"","category":"section"},{"location":"library_management/","page":"Library Management","title":"Library Management","text":"CLibrary\nhandle\nget_symbol\nload_lib\nunload_lib\nis_lib_loaded","category":"page"},{"location":"library_management/#Kokkos.CLibrary","page":"Library Management","title":"Kokkos.CLibrary","text":"CLibrary\n\nA wrapper around a shared library, loaded with Libdl.dlopen.\n\n\n\n\n\n","category":"type"},{"location":"library_management/#Kokkos.handle","page":"Library Management","title":"Kokkos.handle","text":"handle(lib::CLibrary)\n\nReturn the handle (a Ptr{Nothing}) of lib, for use with Libdl.dlsym for example.\n\nIf lib is invalid (not loaded), returns C_NULL.\n\n\n\n\n\n","category":"function"},{"location":"library_management/#Kokkos.get_symbol","page":"Library Management","title":"Kokkos.get_symbol","text":"get_symbol(lib::CLibrary, symbol::Symbol)\n\nLoad the pointer to the given symbol. Symbol pointers are cached: Libdl.dlsym is called only if the symbol is not already in the cache.\n\n\n\n\n\n","category":"function"},{"location":"library_management/#Kokkos.load_lib","page":"Library Management","title":"Kokkos.load_lib","text":"load_lib(lib::Union{String, KokkosProject, CLibrary};\n         flags=Libdl.RTLD_LAZY | Libdl.RTLD_LOCAL)\n\nOpen a shared library.\n\nlib can be the path to the shared library, an existing CLibrary or a KokkosProject. If lib is a project, its target is supposed to be compiled and up-to-date.\n\nIf the library is already loaded, it is not opened another time: this guarantees that calling Libdl.dlclose once will unload the library from memory, if the library wasn't opened from elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"library_management/#Kokkos.unload_lib","page":"Library Management","title":"Kokkos.unload_lib","text":"unload_lib(lib::Union{KokkosProject, CLibrary})\n\nUnload a library. Return true if the library has a valid handle and Libdl.dlclose was called.\n\nBecause of the mechanism behind shared library loading, it is not guaranteed that the library is unloaded from memory after this call. is_lib_loaded is more reliable than the return value of this function.\n\nThe symbol cache of the library is cleared by this function.\n\n\n\n\n\n","category":"function"},{"location":"library_management/#Kokkos.is_lib_loaded","page":"Library Management","title":"Kokkos.is_lib_loaded","text":"is_lib_loaded(lib::Union{KokkosProject, CLibrary})\n\nReturn true if the library was previously loaded by load_lib and is still present in memory.\n\nIf the full path to lib is still present in Libdl.dllist(), the library is considered to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"interop/#Interoperability","page":"Interoperability with CUDA.jl","title":"Interoperability","text":"","category":"section"},{"location":"interop/#CUDA.jl","page":"Interoperability with CUDA.jl","title":"CUDA.jl","text":"","category":"section"},{"location":"interop/","page":"Interoperability with CUDA.jl","title":"Interoperability with CUDA.jl","text":"Views can be converted into CuArrays using Base.unsafe_wrap:","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl","title":"Interoperability with CUDA.jl","text":"Base.unsafe_wrap(::Type{CUDA.CuArray}, ::Kokkos.View)","category":"page"},{"location":"interop/#Base.unsafe_wrap-Tuple{Type{CuArray}, Kokkos.Views.View}","page":"Interoperability with CUDA.jl","title":"Base.unsafe_wrap","text":"unsafe_wrap(CuArray, v::Kokkos.View)\n\nWrap a Kokkos.View into a CuArray. The view must be stored in one of the CUDA device memory spaces.\n\nViews with row-major layout (LayoutRight) will be transposed with Base.adjoint.\n\nNon-contiguous views (Kokkos.span_is_contiguous(v) == false) cannot be represented as CuArrays.\n\nwarning: Warning\nThe returned CuArray does not own the data of the view, which then must stay rooted for the entire lifetime of the CuArray.\n\n\n\n\n\n","category":"method"},{"location":"interop/","page":"Interoperability with CUDA.jl","title":"Interoperability with CUDA.jl","text":"And CuArrays can be converted into views with Kokkos.view_wrap:","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl","title":"Interoperability with CUDA.jl","text":"julia> A = CuArray{Int64}(undef, 4, 4);\n\njulia> CUDA.@allowscalar for i in eachindex(A)\n           A[i] = i\n       end\n\njulia> A\n4Ã—4 CuArray{Int64, 2, CUDA.Mem.DeviceBuffer}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> A_v = Kokkos.view_wrap(A);\n","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl","title":"Interoperability with CUDA.jl","text":"SubArrays of CuArrays (or, more precisely, any CUDA.StridedSubCuArray), can also be converted into views with a LayoutStride:","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl","title":"Interoperability with CUDA.jl","text":"julia> sub_A = @view A[2:3, 2:3];\n\njulia> sub_A isa CUDA.StridedSubCuArray\ntrue\n\njulia> size(sub_A), strides(sub_A)\n((2, 2), (1, 4))\n\njulia> sub_A_v = Kokkos.view_wrap(sub_A);\n\njulia> Kokkos.main_view_type(sub_A_v)\nKokkos.Views.View{Int64, 2, Kokkos.Views.LayoutStride, Kokkos.Spaces.CudaSpace}\n\njulia> size(sub_A_v), strides(sub_A_v)\n((2, 2), (1, 4))","category":"page"},{"location":"interop/","page":"Interoperability with CUDA.jl","title":"Interoperability with CUDA.jl","text":"Unlike Kokkos.View, it is possible to perform arithmetic operations on a CuArray from the host, as well as indexing device memory (if permitted by CUDA.allowscalar(true) or CUDA.@allowscalar).","category":"page"},{"location":"views/","page":"Views","title":"Views","text":"CurrentModule = Kokkos.Views","category":"page"},{"location":"views/#Views","page":"Views","title":"Views","text":"","category":"section"},{"location":"views/#View","page":"Views","title":"View","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"View\naccessible(::View)\nmemory_space(::View)\narray_layout(::View)\nlabel\nview_data\nmemory_span\nspan_is_contiguous\nsubview\nview_wrap\ndeep_copy\ncreate_mirror\ncreate_mirror_view\nimpl_view_type\nmain_view_type","category":"page"},{"location":"views/#Kokkos.Views.View","page":"Views","title":"Kokkos.Views.View","text":"View{T, D, Layout, MemSpace} <: AbstractArray{T, D}\n\nWrapper around a Kokkos::View of D dimensions of type T, stored in MemSpace using the Layout.\n\nBehaves like a normal Array. Indexing is done by calling the Kokkos::View::operator() function of the view, and is therefore not highly performant. The best performance with Kokkos views is achieved by calling Kokkos kernels compiled from C++.\n\nIt is supposed that all view accesses are done from the default host execution space. Since the view may be stored in a memory space different from the host, it may be invalid to access its elements: if accessible(MemSpace) is false, then all view accesses will throw an error.\n\nViews are created through CxxWrap.jl, which adds automatically a finalizer to all objects which calls the view's destructor when the Julia object is deleted by the garbage collector.\n\nIt is important to understand that for a view to be properly disposed of, there is two requirements:\n\nthe library containing its destructor is still loaded. Views created by the Kokkos.jl library will always meet this requirement.\nfinalize wasn't called.\n\n\n\n\n\n","category":"type"},{"location":"views/#Kokkos.Spaces.accessible-Tuple{Kokkos.Views.View}","page":"Views","title":"Kokkos.Spaces.accessible","text":"accessible(::View)\n\nReturn true if the view is accessible from the default host execution space.\n\n\n\n\n\n","category":"method"},{"location":"views/#Kokkos.Spaces.memory_space-Tuple{Kokkos.Views.View}","page":"Views","title":"Kokkos.Spaces.memory_space","text":"memory_space(::View)\n\nThe memory space type in which the view data is stored.\n\njulia> my_cuda_space = Kokkos.CudaSpace()\n ...\n\njulia> v = View{Float64}(undef, 10; mem_space=my_cuda_space)\n ...\n\njulia> memory_space(v)\nKokkos.Spaces.CudaSpace\n\n\n\n\n\n","category":"method"},{"location":"views/#Kokkos.Spaces.array_layout-Tuple{Kokkos.Views.View}","page":"Views","title":"Kokkos.Spaces.array_layout","text":"array_layout(::View)\n\nReturn the Layout type of the view.\n\n\n\n\n\n","category":"method"},{"location":"views/#Kokkos.Views.label","page":"Views","title":"Kokkos.Views.label","text":"label(::View)\n\nReturn the label of the View.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.view_data","page":"Views","title":"Kokkos.Views.view_data","text":"view_data(::View)\n\nThe pointer to the data of the View. Using Base.pointer(view) is preferred over this method.\n\nEquivalent to view.data().\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.memory_span","page":"Views","title":"Kokkos.Views.memory_span","text":"memory_span(::View)\n\nTotal size of the view data in memory, in bytes.\n\nEquivalent to view.impl_map().memory_span().\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.span_is_contiguous","page":"Views","title":"Kokkos.Views.span_is_contiguous","text":"span_is_contiguous(::View)\n\ntrue if the view stores all its elements contiguously in memory.\n\nEquivalent to view.span_is_contiguous().\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.subview","page":"Views","title":"Kokkos.Views.subview","text":"subview(v::View, indexes...)\nsubview(v::View, indexes::Tuple{Vararg{Union{Int, Colon, AbstractUnitRange}}})\n\nReturn a new Kokkos.view which will be a subview into the region specified by indexes of v, with the same memory space (but maybe not the same layout).\n\nUnspecified dimensions are completed by :, e.g. if v is a 3D view (1,) and (1, :, :) will return the same subview.\n\nA subview may need LayoutStride to be compiled in order to be represented.\n\nEquivalent to Kokkos::subview.\n\nKokkos::ALL is equivalent to :.\n\nExample\n\njulia> v = Kokkos.View{Float64}(undef, 4, 4);\n\njulia> v[:] .= collect(1:length(v));\n\njulia> v\n4Ã—4 Kokkos.KokkosWrapper.Impl.View2D_R_HostAllocated{Float64}:\n 1.0  5.0   9.0  13.0\n 2.0  6.0  10.0  14.0\n 3.0  7.0  11.0  15.0\n 4.0  8.0  12.0  16.0\n\njulia> Kokkos.subview(v, (2:3, 2:3))\n2Ã—2 Kokkos.KokkosWrapper.Impl.View2D_R_HostAllocated{Float64}:\n 6.0  10.0\n 7.0  11.0\n\njulia> Kokkos.subview(v, (:, 1))  # The subview may change its layout to `LayoutStride` \n4-element Kokkos.KokkosWrapper.Impl.View1D_S_HostAllocated{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\njulia> Kokkos.subview(v, (1,))  # Equivalent to `(1, :)`\n4-element Kokkos.KokkosWrapper.Impl.View1D_R_HostAllocated{Float64}:\n  1.0\n  5.0\n  9.0\n 13.0\n\nwarning: Warning\nKokkos.subview is not equivalent to Base.view, as it returns a new Kokkos.View object, while Base.view returns a SubArray, which cannot be passed to a ccall.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.view_wrap","page":"Views","title":"Kokkos.Views.view_wrap","text":"view_wrap(array::DenseArray{T, D})\nview_wrap(::Type{View{T, D}}, array::DenseArray{T, D})\n\nview_wrap(array::AbstractArray{T, D})\nview_wrap(::Type{View{T, D}}, array::AbstractArray{T, D})\n\nview_wrap(::Type{View{T, D, L, S}}, d::NTuple{D, Int}, p::Ptr{T}; layout = nothing)\n\nConstruct a new View from the data of a Julia-allocated array (or from any valid array or pointer). The returned view does not own the data: no copy is made.\n\nThe memory space S is HostSpace when array is a DenseArray or AbstractArray, and the layout L is LayoutLeft for DenseArray and LayoutStride for AbstractArray.\n\nIf L is LayoutStride, then the kwarg layout should be an instance of a LayoutStride which specifies the stride of each dimension.\n\nwarning: Warning\nJulia arrays have a column-major layout by default. This correspond to a LayoutLeft, while Kokkos prefers LayoutRight for CPU allocated arrays. If strides(array) â‰  strides(view_wrap(array)) then it might lead to segfaults. This only concerns 2D arrays and above.\n\nwarning: Warning\nThe returned view does not hold a reference to the original array. It is the responsability of the user to make sure the original array is kept alive as long as the view should be accessed.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.deep_copy","page":"Views","title":"Kokkos.Views.deep_copy","text":"deep_copy(dest::View, src::View)\ndeep_copy(space::ExecutionSpace, dest::View, src::View)\n\nPerforms a copy of all data from src to dest.\n\nIn order for the copy to be possible, both views must have the same dimension, and either have the same layout or are both accessible from space.\n\nIf a space is given, the copy may be asynchronous. If not the copy will be synchronous.\n\nEquivalent to Kokkos::deep_copy(dest, src) or Kokkos::deep_copy(space, dest, src). See the Kokkos docs about Kokkos::deep_copy\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.create_mirror","page":"Views","title":"Kokkos.Views.create_mirror","text":"create_mirror(src::View; mem_space = nothing, zero_fill = false)\n\nCreate a new View in the same way as similar(src), with the same layout and padding as src.\n\nIf mem_space is nothing the new view will be in a memory space accessible by the host, otherwise it must be a memory space instance where the new view will be allocated.\n\nIf zero_fill is true, the new view will have all of its elements set to their default value.\n\nSee the Kokkos docs about Kokkos::create_mirror\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.create_mirror_view","page":"Views","title":"Kokkos.Views.create_mirror_view","text":"create_mirror_view(src::View; mem_space = nothing, zero_fill = false)\n\nEquivalent to create_mirror, but if src is already accessible by the host, src is returned and no view is created.\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.impl_view_type","page":"Views","title":"Kokkos.Views.impl_view_type","text":"impl_view_type(::Type{View{T, D, L, S}})\n\nReturns the internal View type for the given complete View type.\n\nThe opposite of main_view_type.\n\njulia> view_t = Kokkos.View{Float64, 2, Kokkos.LayoutRight, Kokkos.HostSpace}\nKokkos.Views.View{Float64, 2, Kokkos.Views.LayoutRight, Kokkos.Spaces.HostSpace}\n\njulia> view_impl_t = Kokkos.impl_view_type(view_t)\nKokkos.KokkosWrapper.Impl.View2D_R_HostAllocated{Float64}\n\njulia> supertype(supertype(view_impl_t))\nKokkos.Views.View{Float64, 2, Kokkos.Views.LayoutRight, Kokkos.KokkosWrapper.Impl.HostSpaceImplAllocated}\n\njulia> view_impl_t <: view_t  # Julia types are contra-variant\nfalse\n\n\n\n\n\n","category":"function"},{"location":"views/#Kokkos.Views.main_view_type","page":"Views","title":"Kokkos.Views.main_view_type","text":"main_view_type(::View)\nmain_view_type(::Type{<:View})\n\nThe \"main type\" of the view: converts Type{View1D_S_HostAllocated{Float64}} into Type{View{Float64, 1, LayoutStride, HostSpace}}, which is easier to understand.\n\nThe opposite of impl_view_type.\n\n\n\n\n\n","category":"function"},{"location":"views/#Layouts","page":"Views","title":"Layouts","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"Layout\nLayoutLeft\nLayoutRight\nLayoutStride","category":"page"},{"location":"views/#Kokkos.Views.Layout","page":"Views","title":"Kokkos.Views.Layout","text":"Layout\n\nAbstract super-type of all view layouts.\n\nSub-types:\n\nLayoutLeft\nLayoutRight\nLayoutStride\n\n\n\n\n\n","category":"type"},{"location":"views/#Kokkos.Views.LayoutLeft","page":"Views","title":"Kokkos.Views.LayoutLeft","text":"LayoutLeft\n\nFortran-style column major array layout. This is also the layout of Julia arrays.\n\nWhile indexing, the first index is the contiguous one: v[i0, i1, i2].\n\nEquivalent to Kokkos::LayoutLeft.\n\n\n\n\n\n","category":"type"},{"location":"views/#Kokkos.Views.LayoutRight","page":"Views","title":"Kokkos.Views.LayoutRight","text":"LayoutRight\n\nC-style row major array layout.\n\nWhile indexing, the last index is the contiguous one: v[i2, i1, i0].\n\nEquivalent to Kokkos::LayoutRight.\n\n\n\n\n\n","category":"type"},{"location":"views/#Kokkos.Views.LayoutStride","page":"Views","title":"Kokkos.Views.LayoutStride","text":"LayoutStride\n\nArbitrary array layout, mostly used for sub-views.\n\nEquivalent to Kokkos::LayoutStride.\n\nWhen building a new view with a LayoutStride, the strides of each dimension must be given to the view constructor:\n\n# A 7Ã—11 matrix with column-major layout\nv = Kokkos.View{Float64}(undef, 7, 11; layout=LayoutStride(1, 11))\n\n# A 7Ã—11 matrix with row-major layout\nv = Kokkos.View{Float64}(undef, 7, 11; layout=LayoutStride(7, 1))\n\nThis differs slightly from the C++ Kokkos constructor, where dimensions and strides are interleaved.\n\n\n\n\n\n","category":"type"},{"location":"views/#Constants","page":"Views","title":"Constants","text":"","category":"section"},{"location":"views/","page":"Views","title":"Views","text":"Idx\nCOMPILED_DIMS\nCOMPILED_TYPES\nCOMPILED_LAYOUTS","category":"page"},{"location":"views/#Kokkos.Views.Idx","page":"Views","title":"Kokkos.Views.Idx","text":"Idx::Type{<:Integer}\n\nInteger type used by views for indexing on the default execution device. Usually either Cint or Clonglong.\n\nEquivalent to Kokkos::RangePolicy<>::index_type.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"views/#Kokkos.Views.COMPILED_DIMS","page":"Views","title":"Kokkos.Views.COMPILED_DIMS","text":"COMPILED_DIMS::Tuple{Vararg{Int32}}\n\nList of all View dimensions which are compiled.\n\nBy default, dimensions 1 and 2 are compiled.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"views/#Kokkos.Views.COMPILED_TYPES","page":"Views","title":"Kokkos.Views.COMPILED_TYPES","text":"COMPILED_TYPES::Tuple{Vararg{DataType}}\n\nList of all View element types which are compiled\n\nBy default, the following types are compiled: Float64 (double), and Int64 (int64_t).\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"views/#Kokkos.Views.COMPILED_LAYOUTS","page":"Views","title":"Kokkos.Views.COMPILED_LAYOUTS","text":"COMPILED_LAYOUTS::Tuple{Vararg{DataType}}\n\nList of all Layouts types which are compiled.\n\nBy default, the default array layout for the device and host execution spaces are compiled.\n\nnothing if Kokkos is not yet loaded.\n\n\n\n\n\n","category":"constant"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"CurrentModule = Kokkos","category":"page"},{"location":"calling_c/#Calling-a-Kokkos-library","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"","category":"section"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Suppose we want to wrap the following function:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"// my_lib.cpp\n#include \"Kokkos_Core.hpp\"\n\nextern \"C\"\nvoid fill_view(Kokkos::View<double*>& view, double value)\n{\n    Kokkos::parallel_for(Kokkos::RangePolicy<>(0, view.size()),\n    KOKKOS_LAMBDA(int i) {\n        view[i] = value;\n    });\n}","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"It is important to understand that here the argument type Kokkos::View<double*>& relies on the default template arguments for the layout type, memory space and memory traits. Therefore, its complete type will change depending on the Kokkos configuration.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"In order for Kokkos.jl to properly call this function, we must build a view from Julia whose type matches exactly the complete type of Kokkos::View<double*>. This requires Kokkos.jl to compile some member functions of the complete Kokkos::View type, as well as its constructors.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"To achieve this you have two options:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"let Kokkos.jl configure the library and itself, guaranteeing that the options match\nthe library containing the function is already compiled, or you cannot/don't want to change its Kokkos configuration: you must configure Kokkos.jl with the exact same options","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"In both cases, this is how you can configure Kokkos.jl for:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"the element type: must be present in view_types\nthe dimension: must be present in view_dims\nthe Layout: must be present in view_layouts\nthe MemorySpace: configured through the backends options\nthe memory traits: not yet implemented","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"All possible combinations of those parameters are compiled when loading Kokkos.jl. For example, if view_types = [Float64, Float32], view_dims = [1, 2], view_layouts = [\"left\", \"right\"] and backends = [Serial, Cuda], there will be a total of 2Ã—2Ã—2Ã—2 = 16 different views compiled.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"note: Note\nYour project is not affected by the view_dims, view_types and view_layouts options. You only need to make sure that the combination of those options cover all usages of views in your project.","category":"page"},{"location":"calling_c/#Your-CMake-project","page":"Calling a Kokkos library","title":"Your CMake project","text":"","category":"section"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"The CMake project shouldn't need extra handling:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"# CMakeLists.txt\ncmake_minimum_required(VERSION 3.20)\nproject(MyLib)\n\nset(CMAKE_CXX_EXTENSIONS OFF)  # Kokkos will warn you if this is not set to OFF\n\nfind_package(Kokkos REQUIRED)\n\nadd_library(MyLib SHARED my_lib.cpp)\ntarget_link_libraries(MyLib PRIVATE Kokkos::kokkos)  # or PUBLIC, it doesn't matter","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"find_package requires the Kokkos_ROOT (or Kokkos_DIR) variable to be set when configuring the project. Kokkos.jl can do that for you. The advantage of this approach is that your project and Kokkos.jl will share the same Kokkos installation, reducing the compilation time.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"If your project uses Kokkos in-tree, you have several options: ","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"keep the call to add_subdirectory the same, and configure kokkos_path to use the same path\nchange it to add_subdirectory(${Kokkos_ROOT} lib/kokkos) (the second argument is arbitrary)","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"warning: Warning\nAll libraries should use Kokkos as a shared library. To do this the cmake option \"BUILD_SHARED_LIBS\" must be \"ON\". Failing to do so will statically link Kokkos to your library, which therefore will not share the same environment as the kokkos wrapper library. This error is invisible in most backends but will create errors in others (like Cuda). When creating a project with a CMakeKokkosProject, \"BUILD_SHARED_LIBS\" will be properly set to \"ON\".","category":"page"},{"location":"calling_c/#Loading-the-wrapper-library-of-Kokkos.jl","page":"Calling a Kokkos library","title":"Loading the wrapper library of Kokkos.jl","text":"","category":"section"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Kokkos.jl relies on a wrapper library written in C++ to compile all possible combinations of Kokkos::View, as described by the Configuration Options, as well as all ExecutionSpace, MemorySpace needed and other functions.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Upon loading Kokkos.jl, this wrapper library is not loaded (and maybe not compiled). Therefore, most Kokkos functions will not work (some methods might be missing, others will raise an error).","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"To load the wrapper library you can use Kokkos.load_wrapper_lib or Kokkos.initialize:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> using Kokkos\n\njulia> Kokkos.load_wrapper_lib()  # Will compile then load the library, it may take some time\n\njulia> Kokkos.initialize()  # Will also call `Kokkos.load_wrapper_lib()` if needed\n","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"note: Note\nThe reason the wrapper library is not loaded when using Kokkos, is for setting the Configuration Options. After Kokkos.load_wrapper_lib() has been called, the configuration options are locked, and require to restart the Julia session for changes to be applied.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"note: Note\nSetting the environment variable JULIA_DEBUG to Kokkos will print all steps and commands called to compile and load the wrapper library, as well as for user libraries.","category":"page"},{"location":"calling_c/#Compiling-and-loading-the-library","page":"Calling a Kokkos library","title":"Compiling and loading the library","text":"","category":"section"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"By default, when loading Kokkos.jl the build files will be stored in a scratch directory, this can be configured with build_dir. It is recommended to build the project files to the same directory, by using the Kokkos.KOKKOS_BUILD_DIR variable. In order for the Configuration Options to be passed correctly, you should use a CMakeKokkosProject:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> my_lib_path = \"./path/to/mylib/project\"\n\"./path/to/mylib/project\"\n\njulia> my_lib_build_path = joinpath(Kokkos.KOKKOS_BUILD_DIR, \"mylib\")\n\"/path/to/scratch/.kokkos-build/mylib\"\n\njulia> project = CMakeKokkosProject(my_lib_path, \"libMyLib\";\n                                    target=\"MyLib\", build_dir=my_lib_build_path)\nKokkos project from sources located at './path/to/mylib/project'\nBuilding in '/path/to/scratch.kokkos-build/mylib'\n...","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"If target is not given, CMakeKokkosProject will build by default all targets of the CMake project. Here \"libMyLib\" is the name of the result of the MyLib target: the library we want to compile and load.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> compile(project)\n\njulia> my_lib = load_lib(project)\nCLibrary(...)","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"The library can then be used the same way as you would with a shared library. Use handle to get a pointer to pass to Libdl.dlsym or use get_symbol to get the address of our fill_view function:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> v = Kokkos.View{Float64}(undef, 10)\n10-element Kokkos.Views.View1D_HostAllocated{Float64}:\n 6.365987373e-314\n 1.14495326e-316\n...\n\njulia> ccall(get_symbol(my_lib, :fill_view),\n             Cvoid, (Ref{Kokkos.View}, Float64),\n             v, 0.1)\n\njulia> v\n10-element Kokkos.Views.View1D_HostAllocated{Float64}:\n 0.1\n 0.1\n...","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"Here we called void fill_view(Kokkos::View<double>&, double), which has been compiled with a single set of template arguments for Kokkos::View. Therefore the ccall is only valid if the view passed to it matches exactly those template arguments. You can further specify the argument types of the ccall to reflect this:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> ccall(get_symbol(my_lib, :fill_view),\n             Cvoid, (Ref{Kokkos.View{Float64, 1, Kokkos.DEFAULT_DEVICE_MEM_SPACE}}, Float64),\n             v, 0.1)","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"The library is opened in a way which allows it to be unloaded afterward using unload_lib:","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"julia> unload_lib(my_lib)\ntrue\n\njulia> is_lib_loaded(my_lib)\nfalse","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"This can be useful in order to reconfigure and recompile the project in the same session, to perform compilation parameters exploration for example. As long as all views are allocated through Kokkos.jl, they can be safely re-used after a library reload.","category":"page"},{"location":"calling_c/","page":"Calling a Kokkos library","title":"Calling a Kokkos library","text":"warning: Warning\nIf any view which has been allocated by an external library is owned by Julia, it must be finalized before unloading the library (i.e. either finalize must be called on the view, or the garbage collector did so automatically beforehand).Failure to do so will result in nasty segfaults when the GC tries to call the finalizer on the view, which also happens when Julia is exiting.The segfault could look like this:signal (11): Segmentation error\nin expression starting at /home/Kokkos/test/runtests.jl:19\nunknown function (ip: 0x7f928f488090)\n_ZN6Kokkos4Impl22SharedAllocationRecordIvvE9decrementEPS2_ at /home/Kokkos/.kokkos-build/wrapper-build-release/lib/kokkos/core/src/libkokkoscore.so.4.0 (unknown line)The main clue that it is a finalizer error is the fact it happens in Kokkos::Impl::SharedAllocationRecord::decrement.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Kokkos","category":"page"},{"location":"#Kokkos.jl","page":"Home","title":"Kokkos.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Kokkos.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kokkos.jl allows you to create Kokkos::View instances from Julia, to configure and compile a Kokkos project or load an existing library, and call its functions and the Kokkos kernels it defines.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kokkos.jl supports all backends of Kokkos.","category":"page"},{"location":"","page":"Home","title":"Home","text":"View inherits the AbstractArray interface of Julia, and can therefore be used as a normal Array. All view accesses are done through calls to Kokkos::View::operator(), and therefore can access CPU or GPU memory seamlessly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nCurrently Kokkos.jl does not create Kokkos kernels (e.g. using Kokkos::parallel_for) since it would require automatic Julia to C++ code convertion. You also cannot run Julia code in Kokkos kernels, since Julia cannot be used in threads it doesn't own (or adopted, in Julia 1.9).","category":"page"}]
}
